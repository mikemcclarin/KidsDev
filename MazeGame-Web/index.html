<!DOCTYPE html>
<html>
<head>
    <title>Maze Pitfalls</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
            margin-bottom: 20px;
            border: 3px solid #334;
        }
        #hud {
            display: none;
        }
    </style>
</head>
<body>
    <h1>MAZE PITFALLS</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="hud">
        <div id="lives">Lives: 10</div>
        <div id="level">Level: 1</div>
        <div id="coins">Coins: 0/5</div>
        <p style="margin-top: 20px; font-size: 16px;">
            Arrow Keys = Move | Spacebar = Jump<br>
            Reach the green EXIT! Collect 5 coins for an extra life!
        </p>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ===================== INFRASTRUCTURE =====================

    let frameCount = 0;
    let gameTime = 0;

    // Particle system
    let particles = [];
    const MAX_PARTICLES = 80;

    function spawnParticle(opts) {
        if (particles.length >= MAX_PARTICLES) return;
        particles.push({
            x: opts.x || 0,
            y: opts.y || 0,
            velX: opts.velX || 0,
            velY: opts.velY || 0,
            life: opts.life || 60,
            maxLife: opts.life || 60,
            size: opts.size || 2,
            color: opts.color || '#fff',
            alpha: opts.alpha !== undefined ? opts.alpha : 1,
            alphaStart: opts.alpha !== undefined ? opts.alpha : 1,
            shrink: opts.shrink !== undefined ? opts.shrink : true,
            gravity: opts.gravity || 0
        });
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.velX;
            p.y += p.velY;
            p.velY += p.gravity;
            p.life--;
            if (p.shrink) {
                p.alpha = p.alphaStart * (p.life / p.maxLife);
            }
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    function drawParticles() {
        for (let p of particles) {
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            const r = p.size * Math.max(0.2, p.life / p.maxLife);
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // Round rectangle utility
    function roundRect(x, y, w, h, r) {
        if (r > w / 2) r = w / 2;
        if (r > h / 2) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    // Deterministic hash for procedural details
    function hash(n) {
        return ((Math.abs(n) * 2654435761) >>> 0) % 1000 / 1000;
    }

    // Starfield (generated once, 3 layers ~100 stars)
    const stars = [];
    for (let layer = 0; layer < 3; layer++) {
        for (let i = 0; i < 33; i++) {
            stars.push({
                x: Math.random() * 800,
                y: Math.random() * 400,
                size: 0.5 + Math.random() * (layer === 0 ? 1.5 : layer === 1 ? 1 : 0.5),
                twinkleSpeed: 0.02 + Math.random() * 0.03,
                twinkleOffset: Math.random() * Math.PI * 2,
                layer: layer
            });
        }
    }

    // ===================== GAME STATE =====================

    let lives = 10;
    let currentLevel = 1;
    let gameOver = false;
    let levelComplete = false;
    let coins = 0;
    const COINS_FOR_LIFE = 5;

    // Death animation state
    let deathAnimating = false;
    let deathAnimTimer = 0;
    const DEATH_ANIM_DURATION = 120;
    let shakeIntensity = 0;
    let deathFlashAlpha = 0;
    let deathTextAlpha = 0;
    let deathParticles = [];
    let deathFreezeFrames = 0;

    // ===================== AUDIO SYSTEM =====================

    let audioCtx = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    function playSound(name) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch(name) {
            case 'jump':
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.1);
                break;
            case 'coin':
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.15);
                break;
            case 'extraLife':
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.15);
                osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.3);
                break;
            case 'death':
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.3);
                break;
            case 'levelComplete':
                osc.frequency.setValueAtTime(500, audioCtx.currentTime);
                osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.1);
                osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.4);
                break;
            case 'victory':
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.setValueAtTime(500, audioCtx.currentTime + 0.15);
                osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.3);
                osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.45);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.6);
                break;
        }
    }

    function playDeathSound() {
        if (!audioCtx) return;

        const noise = audioCtx.createOscillator();
        const noiseGain = audioCtx.createGain();
        noise.type = 'sawtooth';
        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.frequency.setValueAtTime(200, audioCtx.currentTime);
        noise.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.5);
        noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        noise.start(audioCtx.currentTime);
        noise.stop(audioCtx.currentTime + 0.5);

        const rumble = audioCtx.createOscillator();
        const rumbleGain = audioCtx.createGain();
        rumble.type = 'sine';
        rumble.connect(rumbleGain);
        rumbleGain.connect(audioCtx.destination);
        rumble.frequency.setValueAtTime(60, audioCtx.currentTime);
        rumble.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.8);
        rumbleGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
        rumble.start(audioCtx.currentTime);
        rumble.stop(audioCtx.currentTime + 0.8);

        const tone = audioCtx.createOscillator();
        const toneGain = audioCtx.createGain();
        tone.type = 'square';
        tone.connect(toneGain);
        toneGain.connect(audioCtx.destination);
        tone.frequency.setValueAtTime(500, audioCtx.currentTime + 0.1);
        tone.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 1.0);
        toneGain.gain.setValueAtTime(0.15, audioCtx.currentTime + 0.1);
        toneGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
        tone.start(audioCtx.currentTime + 0.1);
        tone.stop(audioCtx.currentTime + 1.0);
    }

    // ===================== PLAYER =====================

    const player = {
        x: 50,
        y: 550,
        width: 14,    // collision hitbox width
        height: 18,   // collision hitbox height
        velX: 0,
        velY: 0,
        speed: 5,
        jumping: false,
        startX: 50,
        startY: 550,
        animFrame: 0,
        facing: 1,
        // Visual animation properties
        squashStretch: 1,
        wasOnGround: false,
        onGround: false,
        landTimer: 0,
        breathPhase: 0,
        trailHistory: [],
        runPhase: 0,
        eyeBlinkTimer: 100,
        isBlinking: false
    };

    // ===================== INPUT =====================

    const keys = {};
    window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        initAudio();
        if (e.key === ' ') {
            e.preventDefault();
            if (!player.jumping) {
                player.velY = -12;
                player.jumping = true;
                playSound('jump');
            }
        }
        if ((e.key === 'r' || e.key === 'R' || e.key === 'Enter') && gameOver) {
            e.preventDefault();
            lives = 10;
            currentLevel = 1;
            coins = 0;
            gameOver = false;
            levelComplete = false;
            deathAnimating = false;
            deathParticles = [];
            particles = [];
            resetLevel();
        }
    });
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // ===================== LEVELS =====================

    const levels = {
        1: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 100, y: 500, width: 200, height: 20},
                {x: 420, y: 450, width: 200, height: 20},
                {x: 200, y: 400, width: 150, height: 20},
                {x: 500, y: 350, width: 150, height: 20}
            ],
            pits: [
                {x: 350, y: 520, width: 80, height: 60}
            ],
            spikes: [
                {x: 600, y: 560, width: 80, height: 40}
            ],
            coins: [
                {x: 150, y: 470, collected: false},
                {x: 520, y: 420, collected: false}
            ],
            movingObstacles: [],
            goal: {x: 750, y: 500, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        2: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 50, y: 530, width: 120, height: 20},
                {x: 200, y: 480, width: 120, height: 20},
                {x: 350, y: 430, width: 120, height: 20},
                {x: 500, y: 380, width: 120, height: 20},
                {x: 650, y: 330, width: 150, height: 20}
            ],
            pits: [
                {x: 150, y: 540, width: 50, height: 60},
                {x: 300, y: 490, width: 50, height: 60},
                {x: 450, y: 440, width: 50, height: 60},
                {x: 600, y: 390, width: 50, height: 60}
            ],
            spikes: [
                {x: 100, y: 560, width: 40, height: 40},
                {x: 250, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 85, y: 500, collected: false},
                {x: 235, y: 450, collected: false},
                {x: 385, y: 400, collected: false},
                {x: 700, y: 300, collected: false}
            ],
            movingObstacles: [],
            goal: {x: 740, y: 250, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        3: {
            platforms: [
                {x: 0, y: 580, width: 150, height: 20},
                {x: 200, y: 530, width: 100, height: 20},
                {x: 350, y: 480, width: 100, height: 20},
                {x: 500, y: 430, width: 100, height: 20},
                {x: 650, y: 380, width: 150, height: 20}
            ],
            pits: [
                {x: 150, y: 540, width: 50, height: 60},
                {x: 450, y: 440, width: 50, height: 60}
            ],
            spikes: [
                {x: 300, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 240, y: 500, collected: false},
                {x: 540, y: 400, collected: false}
            ],
            movingObstacles: [],
            goal: {x: 740, y: 300, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        4: {
            platforms: [
                {x: 0, y: 580, width: 200, height: 20},
                {x: 250, y: 520, width: 150, height: 20},
                {x: 450, y: 460, width: 150, height: 20},
                {x: 650, y: 400, width: 150, height: 20}
            ],
            pits: [
                {x: 200, y: 540, width: 50, height: 60}
            ],
            spikes: [
                {x: 350, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 300, y: 490, collected: false},
                {x: 700, y: 370, collected: false}
            ],
            movingObstacles: [
                {x: 480, y: 430, width: 30, height: 30, startX: 450, endX: 570, speed: 2, direction: 1, type: 'horizontal'}
            ],
            goal: {x: 750, y: 320, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        5: {
            platforms: [
                {x: 0, y: 580, width: 150, height: 20},
                {x: 50, y: 500, width: 100, height: 20},
                {x: 180, y: 420, width: 100, height: 20},
                {x: 320, y: 340, width: 100, height: 20},
                {x: 460, y: 260, width: 100, height: 20},
                {x: 600, y: 180, width: 200, height: 20}
            ],
            pits: [],
            spikes: [
                {x: 200, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 220, y: 390, collected: false},
                {x: 360, y: 310, collected: false},
                {x: 500, y: 230, collected: false}
            ],
            movingObstacles: [
                {x: 620, y: 120, width: 30, height: 30, startY: 100, endY: 150, speed: 1.5, direction: 1, type: 'vertical'}
            ],
            goal: {x: 740, y: 100, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        6: {
            platforms: [
                {x: 0, y: 580, width: 120, height: 20},
                {x: 170, y: 520, width: 120, height: 20},
                {x: 50, y: 440, width: 120, height: 20},
                {x: 220, y: 360, width: 120, height: 20},
                {x: 400, y: 300, width: 120, height: 20},
                {x: 570, y: 240, width: 120, height: 20},
                {x: 650, y: 400, width: 100, height: 20}
            ],
            pits: [
                {x: 120, y: 540, width: 50, height: 60}
            ],
            spikes: [
                {x: 300, y: 560, width: 40, height: 40},
                {x: 500, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 90, y: 410, collected: false},
                {x: 260, y: 330, collected: false},
                {x: 610, y: 210, collected: false}
            ],
            movingObstacles: [
                {x: 430, y: 270, width: 30, height: 30, startX: 400, endX: 490, speed: 2, direction: 1, type: 'horizontal'}
            ],
            goal: {x: 700, y: 320, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        7: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 150, y: 520, width: 100, height: 20},
                {x: 300, y: 460, width: 100, height: 20},
                {x: 450, y: 400, width: 100, height: 20},
                {x: 300, y: 320, width: 100, height: 20},
                {x: 500, y: 260, width: 100, height: 20},
                {x: 650, y: 200, width: 150, height: 20}
            ],
            pits: [
                {x: 100, y: 540, width: 50, height: 60},
                {x: 250, y: 480, width: 50, height: 60}
            ],
            spikes: [
                {x: 400, y: 560, width: 40, height: 40},
                {x: 600, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 190, y: 490, collected: false},
                {x: 340, y: 430, collected: false},
                {x: 540, y: 230, collected: false}
            ],
            movingObstacles: [
                {x: 320, y: 290, width: 25, height: 25, startX: 300, endX: 375, speed: 2, direction: 1, type: 'horizontal'},
                {x: 680, y: 130, width: 25, height: 25, startY: 120, endY: 170, speed: 1.5, direction: 1, type: 'vertical'}
            ],
            goal: {x: 740, y: 120, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        8: {
            platforms: [
                {x: 0, y: 580, width: 80, height: 20},
                {x: 120, y: 530, width: 80, height: 20},
                {x: 240, y: 480, width: 80, height: 20},
                {x: 360, y: 430, width: 80, height: 20},
                {x: 480, y: 380, width: 80, height: 20},
                {x: 600, y: 330, width: 80, height: 20},
                {x: 700, y: 280, width: 100, height: 20}
            ],
            pits: [
                {x: 80, y: 540, width: 40, height: 60},
                {x: 320, y: 440, width: 40, height: 60}
            ],
            spikes: [
                {x: 200, y: 560, width: 30, height: 30},
                {x: 440, y: 560, width: 30, height: 30},
                {x: 560, y: 560, width: 30, height: 30}
            ],
            coins: [
                {x: 150, y: 500, collected: false},
                {x: 270, y: 450, collected: false},
                {x: 390, y: 400, collected: false},
                {x: 630, y: 300, collected: false}
            ],
            movingObstacles: [
                {x: 500, y: 350, width: 25, height: 25, startX: 480, endX: 535, speed: 2.5, direction: 1, type: 'horizontal'},
                {x: 720, y: 220, width: 25, height: 25, startY: 200, endY: 250, speed: 2, direction: 1, type: 'vertical'}
            ],
            goal: {x: 740, y: 200, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        },
        9: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 80, y: 500, width: 80, height: 20},
                {x: 200, y: 430, width: 80, height: 20},
                {x: 320, y: 360, width: 80, height: 20},
                {x: 200, y: 280, width: 80, height: 20},
                {x: 350, y: 210, width: 80, height: 20},
                {x: 500, y: 150, width: 80, height: 20},
                {x: 650, y: 100, width: 150, height: 20}
            ],
            pits: [
                {x: 160, y: 540, width: 40, height: 60}
            ],
            spikes: [
                {x: 250, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 110, y: 470, collected: false},
                {x: 230, y: 400, collected: false},
                {x: 230, y: 250, collected: false},
                {x: 530, y: 120, collected: false}
            ],
            movingObstacles: [
                {x: 340, y: 330, width: 25, height: 25, startX: 320, endX: 375, speed: 2, direction: 1, type: 'horizontal'},
                {x: 220, y: 250, width: 25, height: 25, startY: 200, endY: 250, speed: 1.5, direction: 1, type: 'vertical'},
                {x: 520, y: 100, width: 25, height: 25, startX: 500, endX: 555, speed: 2.5, direction: 1, type: 'horizontal'}
            ],
            goal: {x: 740, y: 20, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        10: {
            platforms: [
                {x: 0, y: 580, width: 80, height: 20},
                {x: 130, y: 530, width: 70, height: 20},
                {x: 250, y: 480, width: 70, height: 20},
                {x: 130, y: 400, width: 70, height: 20},
                {x: 250, y: 330, width: 70, height: 20},
                {x: 380, y: 280, width: 70, height: 20},
                {x: 510, y: 220, width: 70, height: 20},
                {x: 380, y: 150, width: 70, height: 20},
                {x: 550, y: 100, width: 70, height: 20},
                {x: 680, y: 60, width: 120, height: 20}
            ],
            pits: [
                {x: 80, y: 540, width: 50, height: 60},
                {x: 200, y: 490, width: 50, height: 60}
            ],
            spikes: [
                {x: 320, y: 560, width: 40, height: 40},
                {x: 450, y: 560, width: 40, height: 40},
                {x: 600, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 155, y: 500, collected: false},
                {x: 155, y: 370, collected: false},
                {x: 280, y: 300, collected: false},
                {x: 540, y: 190, collected: false},
                {x: 720, y: 30, collected: false}
            ],
            movingObstacles: [
                {x: 270, y: 450, width: 25, height: 25, startX: 250, endX: 295, speed: 2, direction: 1, type: 'horizontal'},
                {x: 270, y: 300, width: 25, height: 25, startX: 250, endX: 295, speed: 2.5, direction: -1, type: 'horizontal'},
                {x: 400, y: 250, width: 25, height: 25, startX: 380, endX: 425, speed: 2, direction: 1, type: 'horizontal'},
                {x: 580, y: 50, width: 25, height: 25, startY: 30, endY: 70, speed: 2, direction: 1, type: 'vertical'}
            ],
            goal: {x: 740, y: -20, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        }
    };

    // ===================== LEVEL MANAGEMENT =====================

    function resetLevelCoins() {
        const level = levels[currentLevel];
        if (level.coins) {
            for (let coin of level.coins) {
                coin.collected = false;
            }
        }
    }

    function resetLevel() {
        const level = levels[currentLevel];
        player.x = level.playerStart.x;
        player.y = level.playerStart.y;
        player.startX = level.playerStart.x;
        player.startY = level.playerStart.y;
        player.velX = 0;
        player.velY = 0;
        player.jumping = false;
        player.squashStretch = 1;
        player.wasOnGround = false;
        player.onGround = false;
        player.landTimer = 0;
        player.breathPhase = 0;
        player.trailHistory = [];
        player.runPhase = 0;
        player.eyeBlinkTimer = 100;
        player.isBlinking = false;
        levelComplete = false;
        coins = 0;
        particles = [];
        resetLevelCoins();
    }

    // ===================== DEATH SYSTEM =====================

    function spawnDeathParticles(x, y) {
        deathParticles = [];
        for (let i = 0; i < 20; i++) {
            deathParticles.push({
                x: x,
                y: y,
                velX: (Math.random() - 0.5) * 8,
                velY: (Math.random() - 0.5) * 8 - 3,
                life: 60 + Math.random() * 40,
                size: 2 + Math.random() * 4,
                color: Math.random() > 0.5 ? '#ff0000' : '#ffff00'
            });
        }
    }

    function triggerDeath() {
        lives--;
        playDeathSound();
        deathAnimating = true;
        deathAnimTimer = 0;
        shakeIntensity = 12;
        deathFlashAlpha = 1.0;
        deathTextAlpha = 0;
        deathFreezeFrames = 10;
        spawnDeathParticles(player.x + player.width / 2, player.y + player.height / 2);
    }

    function updateDeathAnimation() {
        if (deathFreezeFrames > 0) {
            deathFreezeFrames--;
            return;
        }

        deathAnimTimer++;
        shakeIntensity = Math.max(0, 12 * (1 - deathAnimTimer / 40));
        deathFlashAlpha = Math.max(0, 1.0 - deathAnimTimer / 15);

        if (deathAnimTimer > 15 && deathAnimTimer < 100) {
            deathTextAlpha = Math.min(1, deathTextAlpha + 0.08);
        } else if (deathAnimTimer >= 100) {
            deathTextAlpha = Math.max(0, deathTextAlpha - 0.05);
        }

        for (let p of deathParticles) {
            p.x += p.velX;
            p.y += p.velY;
            p.velY += 0.15;
            p.life--;
            p.size *= 0.98;
        }
        deathParticles = deathParticles.filter(p => p.life > 0);

        if (deathAnimTimer >= DEATH_ANIM_DURATION) {
            deathAnimating = false;
            deathTextAlpha = 0;
            deathFlashAlpha = 0;
            shakeIntensity = 0;
            deathParticles = [];
            if (lives <= 0) {
                gameOver = true;
            } else {
                resetLevel();
            }
        }
    }

    function drawDeathEffects() {
        if (deathFlashAlpha > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${deathFlashAlpha * 0.6})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        for (let p of deathParticles) {
            ctx.globalAlpha = Math.min(1, p.life / 20);
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.globalAlpha = 1;

        if (deathTextAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = deathTextAlpha;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, canvas.height / 2 - 60, canvas.width, 120);
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('YOU DIED', canvas.width / 2, canvas.height / 2 + 10);
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ff4444';
            ctx.fillText('YOU DIED', canvas.width / 2, canvas.height / 2 + 10);
            ctx.restore();
        }
    }

    // ===================== COLLISION =====================

    function checkCoinCollision() {
        const level = levels[currentLevel];
        if (!level.coins) return;

        for (let coin of level.coins) {
            if (coin.collected) continue;

            const coinRadius = 10;
            const coinCenterX = coin.x + coinRadius;
            const coinCenterY = coin.y + coinRadius;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            const dx = coinCenterX - playerCenterX;
            const dy = coinCenterY - playerCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Generous pickup radius to compensate for smaller hitbox
            if (distance < coinRadius + player.width / 2 + 6) {
                coin.collected = true;
                coins++;
                playSound('coin');

                if (coins >= COINS_FOR_LIFE) {
                    coins = 0;
                    lives++;
                    playSound('extraLife');
                }
            }
        }
    }

    function updateMovingObstacles() {
        const level = levels[currentLevel];
        if (!level.movingObstacles) return;

        for (let obs of level.movingObstacles) {
            if (obs.type === 'horizontal') {
                obs.x += obs.speed * obs.direction;
                if (obs.x <= obs.startX || obs.x + obs.width >= obs.endX + obs.width) {
                    obs.direction *= -1;
                }
            } else if (obs.type === 'vertical') {
                obs.y += obs.speed * obs.direction;
                if (obs.y <= obs.startY || obs.y + obs.height >= obs.endY + obs.height) {
                    obs.direction *= -1;
                }
            }
        }
    }

    function checkMovingObstacleCollision() {
        const level = levels[currentLevel];
        if (!level.movingObstacles) return false;

        for (let obs of level.movingObstacles) {
            if (
                player.x + player.width > obs.x &&
                player.x < obs.x + obs.width &&
                player.y + player.height > obs.y &&
                player.y < obs.y + obs.height
            ) {
                return true;
            }
        }
        return false;
    }

    // ===================== PLAYER UPDATE =====================

    function updatePlayer() {
        // Track previous ground state for landing detection
        player.wasOnGround = player.onGround;

        // Horizontal movement
        player.velX = 0;
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            player.velX = -player.speed;
            player.facing = -1;
        }
        if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            player.velX = player.speed;
            player.facing = 1;
        }

        player.x += player.velX;

        // Gravity
        player.velY += 0.8;
        player.y += player.velY;

        // Boundary check
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

        // Platform collision
        let onPlatform = false;
        const level = levels[currentLevel];
        for (let platform of level.platforms) {
            if (
                player.velY >= 0 &&
                player.y + player.height <= platform.y + 5 &&
                player.y + player.height + player.velY >= platform.y &&
                player.x + player.width > platform.x &&
                player.x < platform.x + platform.width
            ) {
                player.y = platform.y - player.height;
                player.velY = 0;
                player.jumping = false;
                onPlatform = true;
            }
        }

        player.onGround = onPlatform;

        // Pit collision
        for (let pit of level.pits) {
            if (
                player.x + player.width > pit.x &&
                player.x < pit.x + pit.width &&
                player.y + player.height > pit.y &&
                player.y < pit.y + pit.height
            ) {
                triggerDeath();
                return;
            }
        }

        // Spike collision
        for (let spike of level.spikes) {
            if (
                player.x + player.width > spike.x &&
                player.x < spike.x + spike.width &&
                player.y + player.height > spike.y &&
                player.y < spike.y + spike.height
            ) {
                triggerDeath();
                return;
            }
        }

        // Moving obstacle collision
        if (checkMovingObstacleCollision()) {
            triggerDeath();
            return;
        }

        // Fall into void
        if (player.y > canvas.height) {
            triggerDeath();
            return;
        }

        // Coin collision
        checkCoinCollision();

        // Goal collision
        if (
            player.x + player.width > level.goal.x &&
            player.x < level.goal.x + level.goal.width &&
            player.y + player.height > level.goal.y &&
            player.y < level.goal.y + level.goal.height
        ) {
            levelComplete = true;
            if (currentLevel < 10) {
                playSound('levelComplete');
            } else {
                playSound('victory');
            }
        }

        // --- Animation state updates ---

        // Landing squash
        if (player.onGround && !player.wasOnGround) {
            player.squashStretch = 0.7;
            player.landTimer = 8;
        }
        if (player.landTimer > 0) {
            player.landTimer--;
            player.squashStretch += (1 - player.squashStretch) * 0.3;
        }

        // Jump stretch
        if (player.velY < -5) {
            player.squashStretch = 1.3;
        } else if (player.onGround && player.landTimer <= 0) {
            player.squashStretch += (1 - player.squashStretch) * 0.2;
        }

        // Breathing
        player.breathPhase += 0.03;

        // Run phase
        if (Math.abs(player.velX) > 0.5 && player.onGround) {
            player.runPhase += 0.3;
        }

        // Eye blink timer
        player.eyeBlinkTimer--;
        if (player.eyeBlinkTimer <= 0) {
            if (player.isBlinking) {
                player.isBlinking = false;
                player.eyeBlinkTimer = 120 + Math.floor(Math.random() * 180);
            } else {
                player.isBlinking = true;
                player.eyeBlinkTimer = 6;
            }
        }

        // Trail history
        if (Math.abs(player.velX) > 1 || Math.abs(player.velY) > 1) {
            player.trailHistory.unshift({x: player.x, y: player.y, facing: player.facing});
            if (player.trailHistory.length > 5) player.trailHistory.pop();
        } else {
            player.trailHistory = [];
        }

        // Legacy anim frame
        if (onPlatform && player.velX !== 0) {
            player.animFrame = (player.animFrame + 0.15) % 2;
        } else {
            player.animFrame = 0;
        }
    }

    // ===================== DRAWING: BACKGROUND =====================

    function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0a2e');
        grad.addColorStop(0.5, '#0d1b3e');
        grad.addColorStop(1, '#1a3a3a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawStars() {
        for (let star of stars) {
            const twinkle = 0.4 + 0.6 * Math.sin(gameTime * star.twinkleSpeed + star.twinkleOffset);
            ctx.globalAlpha = twinkle * 0.8;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    function drawHills() {
        // Far hills (darker)
        ctx.fillStyle = '#0a1a2a';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x = 0; x <= canvas.width; x += 4) {
            const y = canvas.height - 120 + Math.sin(x * 0.008 + 1) * 40 + Math.sin(x * 0.015) * 20;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.fill();

        // Near hills (lighter)
        ctx.fillStyle = '#0d2235';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x = 0; x <= canvas.width; x += 4) {
            const y = canvas.height - 80 + Math.sin(x * 0.012 + 3) * 30 + Math.sin(x * 0.02) * 15;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.fill();
    }

    // ===================== DRAWING: PLATFORMS =====================

    function drawPlatform(p) {
        // Dirt body gradient
        const dirtGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
        dirtGrad.addColorStop(0, '#8B5A2B');
        dirtGrad.addColorStop(1, '#5C3A1E');
        ctx.fillStyle = dirtGrad;
        roundRect(p.x, p.y, p.width, p.height, 4);
        ctx.fill();

        // Side/bottom edge shading
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        roundRect(p.x + 0.5, p.y + 0.5, p.width - 1, p.height - 1, 4);
        ctx.stroke();

        // Dirt texture specks
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        const numSpecks = Math.floor(p.width / 15);
        for (let i = 0; i < numSpecks; i++) {
            const sx = p.x + hash(i * 73 + p.x) * p.width;
            const sy = p.y + 7 + hash(i * 137 + p.y) * Math.max(1, p.height - 8);
            ctx.fillRect(sx, sy, 2, 1);
        }

        // Green grass top layer
        const grassGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 6);
        grassGrad.addColorStop(0, '#4CAF50');
        grassGrad.addColorStop(1, '#2E7D32');
        ctx.fillStyle = grassGrad;
        roundRect(p.x, p.y, p.width, 6, 3);
        ctx.fill();

        // Grass blades on top edge
        ctx.fillStyle = '#66BB6A';
        for (let bx = p.x + 4; bx < p.x + p.width - 4; bx += 8) {
            const h = hash(bx * 100 + p.y);
            const bladeH = 3 + h * 5;
            const offset = hash(bx * 200 + p.y) * 4 - 2;
            ctx.beginPath();
            ctx.moveTo(bx + offset, p.y);
            ctx.lineTo(bx + offset + 2, p.y - bladeH);
            ctx.lineTo(bx + offset + 4, p.y);
            ctx.fill();
        }
    }

    // ===================== DRAWING: PITS =====================

    function drawPit(pit) {
        // Deep black gradient
        const grad = ctx.createLinearGradient(pit.x, pit.y, pit.x, pit.y + pit.height);
        grad.addColorStop(0, '#111');
        grad.addColorStop(0.5, '#080808');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fillRect(pit.x, pit.y, pit.width, pit.height);

        // Jagged edge triangles at top
        ctx.fillStyle = '#1a1a1a';
        for (let i = 0; i < pit.width; i += 12) {
            const jagH = 4 + ((i * 7 + pit.x * 3) % 8);
            ctx.beginPath();
            ctx.moveTo(pit.x + i, pit.y);
            ctx.lineTo(pit.x + i + 6, pit.y - jagH);
            ctx.lineTo(pit.x + i + 12, pit.y);
            ctx.fill();
        }

        // Spawn rising mist particles
        if (frameCount % 8 === 0) {
            spawnParticle({
                x: pit.x + Math.random() * pit.width,
                y: pit.y + 5,
                velX: (Math.random() - 0.5) * 0.3,
                velY: -0.3 - Math.random() * 0.5,
                life: 40 + Math.random() * 30,
                size: 3 + Math.random() * 3,
                color: '#7777aa',
                alpha: 0.3
            });
        }
    }

    // ===================== DRAWING: SPIKES =====================

    function drawSpike(spike) {
        // Stone base block
        ctx.fillStyle = '#333';
        ctx.fillRect(spike.x, spike.y + spike.height - 8, spike.width, 8);

        // Multiple sharp triangles
        const numTriangles = Math.max(1, Math.floor(spike.width / 16));
        const triWidth = spike.width / numTriangles;

        for (let i = 0; i < numTriangles; i++) {
            const tx = spike.x + i * triWidth;
            const triH = spike.height - 8;

            // Gradient triangle
            const grad = ctx.createLinearGradient(tx + triWidth / 2, spike.y, tx + triWidth / 2, spike.y + triH);
            grad.addColorStop(0, '#ff2200');
            grad.addColorStop(1, '#660000');
            ctx.fillStyle = grad;

            ctx.beginPath();
            ctx.moveTo(tx, spike.y + triH);
            ctx.lineTo(tx + triWidth / 2, spike.y);
            ctx.lineTo(tx + triWidth, spike.y + triH);
            ctx.fill();

            // Glowing red dot at tip
            ctx.save();
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(tx + triWidth / 2, spike.y + 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // ===================== DRAWING: COINS =====================

    function drawCoin(coin) {
        const time = gameTime * 0.05;
        const bounce = Math.sin(time + coin.x * 0.1) * 3;
        const cx = coin.x + 10;
        const cy = coin.y + 10 + bounce;
        const xScale = Math.abs(Math.cos(time + coin.x * 0.05));

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(Math.max(0.1, xScale), 1);

        // Outer glow
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 12;

        // Radial gradient
        const grad = ctx.createRadialGradient(0, -2, 1, 0, 0, 10);
        grad.addColorStop(0, '#fff8dc');
        grad.addColorStop(0.5, '#ffd700');
        grad.addColorStop(1, '#b8860b');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();

        // Inner ring stroke
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#daa520';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 7, 0, Math.PI * 2);
        ctx.stroke();

        // "$" emblem when face-on
        if (xScale > 0.5) {
            ctx.fillStyle = '#8B6914';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$', 0, 1);
        }

        ctx.restore();

        // Spawn sparkle particles periodically
        if (frameCount % 30 === Math.floor(coin.x) % 30) {
            spawnParticle({
                x: cx + (Math.random() - 0.5) * 16,
                y: cy + (Math.random() - 0.5) * 16,
                velX: (Math.random() - 0.5) * 0.5,
                velY: -Math.random() * 0.5,
                life: 20 + Math.random() * 20,
                size: 1.5,
                color: '#ffd700'
            });
        }
    }

    // ===================== DRAWING: GOAL =====================

    function drawGoal(goal) {
        const cx = goal.x + goal.width / 2;
        const cy = goal.y + goal.height / 2;

        // Stone frame
        ctx.fillStyle = '#555';
        ctx.fillRect(goal.x - 4, goal.y - 4, goal.width + 8, goal.height + 8);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.strokeRect(goal.x - 4, goal.y - 4, goal.width + 8, goal.height + 8);

        // Inner portal gradient
        const portalGrad = ctx.createRadialGradient(cx, cy, 5, cx, cy, goal.width);
        portalGrad.addColorStop(0, '#00ffcc');
        portalGrad.addColorStop(0.5, '#0066ff');
        portalGrad.addColorStop(1, '#220044');
        ctx.fillStyle = portalGrad;
        ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

        // Swirling concentric ellipses
        ctx.save();
        ctx.beginPath();
        ctx.rect(goal.x, goal.y, goal.width, goal.height);
        ctx.clip();

        for (let i = 0; i < 4; i++) {
            const t = gameTime * 0.03 + i * 1.5;
            const rx = 6 + i * 4;
            const ry = 12 + i * 8;
            ctx.strokeStyle = `rgba(0, 255, 200, ${0.6 - i * 0.12})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(cx, cy, rx * Math.abs(Math.sin(t)), ry * Math.abs(Math.cos(t * 0.7)), t, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();

        // Center glow
        ctx.save();
        ctx.shadowColor = '#00ffaa';
        ctx.shadowBlur = 20;
        const centerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 10);
        centerGrad.addColorStop(0, 'rgba(255,255,255,0.8)');
        centerGrad.addColorStop(1, 'rgba(0,255,200,0)');
        ctx.fillStyle = centerGrad;
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Pulsing "EXIT" text
        const pulse = 0.6 + 0.4 * Math.sin(gameTime * 0.08);
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.fillStyle = '#00ff88';
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('EXIT', cx, cy);
        ctx.restore();

        // Spawn particles sucked inward toward center
        if (frameCount % 5 === 0) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            spawnParticle({
                x: cx + Math.cos(angle) * dist,
                y: cy + Math.sin(angle) * dist,
                velX: -Math.cos(angle) * 1.5,
                velY: -Math.sin(angle) * 1.5,
                life: 20,
                size: 2,
                color: '#00ffaa'
            });
        }
    }

    // ===================== DRAWING: MOVING OBSTACLES =====================

    function drawMovingObstacle(obs) {
        const cx = obs.x + obs.width / 2;
        const cy = obs.y + obs.height / 2;
        const pulse = 1 + 0.05 * Math.sin(gameTime * 0.1);
        const r = obs.width / 2 * pulse;

        ctx.save();

        // Danger glow
        ctx.shadowColor = '#ff1493';
        ctx.shadowBlur = 15;

        // Radial gradient body
        const grad = ctx.createRadialGradient(cx, cy - 2, 2, cx, cy, r);
        grad.addColorStop(0, '#ff69b4');
        grad.addColorStop(0.7, '#c71585');
        grad.addColorStop(1, '#8b0050');
        ctx.fillStyle = grad;

        // Spiky blob shape
        ctx.beginPath();
        const points = 12;
        for (let i = 0; i <= points; i++) {
            const angle = (i / points) * Math.PI * 2;
            const bump = (i % 2 === 0) ? r * 1.15 : r * 0.9;
            const bx = cx + Math.cos(angle) * bump;
            const by = cy + Math.sin(angle) * bump;
            if (i === 0) ctx.moveTo(bx, by);
            else ctx.lineTo(bx, by);
        }
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;

        // Angry eyes that track toward the player
        const dx = player.x + player.width / 2 - cx;
        const dy = player.y + player.height / 2 - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const lookX = (dx / dist) * 2;
        const lookY = (dy / dist) * 2;

        const eyeSpacing = r * 0.35;

        // Eye whites
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(cx - eyeSpacing, cy - 2, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx + eyeSpacing, cy - 2, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pupils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(cx - eyeSpacing + lookX, cy - 2 + lookY, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(cx + eyeSpacing + lookX, cy - 2 + lookY, 2, 0, Math.PI * 2);
        ctx.fill();

        // Angry eyebrows
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - eyeSpacing - 4, cy - 8);
        ctx.lineTo(cx - eyeSpacing + 3, cy - 6);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + eyeSpacing + 4, cy - 8);
        ctx.lineTo(cx + eyeSpacing - 3, cy - 6);
        ctx.stroke();

        // Jagged mouth
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(cx - 5, cy + 5);
        ctx.lineTo(cx - 3, cy + 3);
        ctx.lineTo(cx, cy + 6);
        ctx.lineTo(cx + 3, cy + 3);
        ctx.lineTo(cx + 5, cy + 5);
        ctx.lineTo(cx + 3, cy + 7);
        ctx.lineTo(cx, cy + 5);
        ctx.lineTo(cx - 3, cy + 7);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    // ===================== DRAWING: PLAYER =====================

    function drawPlayerCharacter(px, py, pfacing, alpha) {
        // px, py = hitbox top-left; draw visual centered on hitbox
        const cx = px + player.width / 2;
        const footY = py + player.height;
        const breathBob = player.onGround && Math.abs(player.velX) < 0.5 ? Math.sin(player.breathPhase) * 1.0 : 0;

        const sy = player.squashStretch;
        const sx = 1 / Math.sqrt(sy);

        ctx.save();
        if (alpha !== undefined) ctx.globalAlpha = alpha;
        ctx.translate(cx, footY);
        ctx.scale(pfacing * sx, sy);

        // Colors
        const bodyColor = '#2bbcc4';
        const bodyDark = '#1a8a90';
        const skinColor = '#ffdab9';
        const capColor = '#cc2222';
        const legColor = '#1a1a40';
        const shoeColor = '#cc2222';

        // --- LEGS ---
        const legSpread = 4;
        const legW = 5;
        const legLen = 10;

        if (player.jumping) {
            // Tucked legs
            ctx.fillStyle = legColor;
            ctx.fillRect(-legSpread - legW / 2, -12, legW, 7);
            ctx.fillRect(legSpread - legW / 2, -12, legW, 7);
            ctx.fillStyle = shoeColor;
            ctx.fillRect(-legSpread - legW / 2, -5, legW + 1, 3);
            ctx.fillRect(legSpread - legW / 2, -5, legW + 1, 3);
        } else if (Math.abs(player.velX) > 0.5 && player.onGround) {
            // Run cycle with rotation
            const phase = player.runPhase;

            // Left leg
            ctx.save();
            ctx.translate(-legSpread, -legLen - 2);
            ctx.rotate(Math.sin(phase) * 0.5);
            ctx.fillStyle = legColor;
            ctx.fillRect(-legW / 2, 0, legW, legLen);
            ctx.fillStyle = shoeColor;
            ctx.fillRect(-legW / 2, legLen - 3, legW + 1, 4);
            ctx.restore();

            // Right leg
            ctx.save();
            ctx.translate(legSpread, -legLen - 2);
            ctx.rotate(Math.sin(phase + Math.PI) * 0.5);
            ctx.fillStyle = legColor;
            ctx.fillRect(-legW / 2, 0, legW, legLen);
            ctx.fillStyle = shoeColor;
            ctx.fillRect(-legW / 2, legLen - 3, legW + 1, 4);
            ctx.restore();
        } else {
            // Standing
            ctx.fillStyle = legColor;
            ctx.fillRect(-legSpread - legW / 2, -legLen - 2, legW, legLen);
            ctx.fillRect(legSpread - legW / 2, -legLen - 2, legW, legLen);
            ctx.fillStyle = shoeColor;
            ctx.fillRect(-legSpread - legW / 2, -5, legW + 1, 3);
            ctx.fillRect(legSpread - legW / 2, -5, legW + 1, 3);
        }

        // --- BODY ---
        const bodyW = 16;
        const bodyH = 12;
        const bodyTop = -legLen - 2 - bodyH + breathBob;

        const bodyGrad = ctx.createLinearGradient(0, bodyTop, 0, bodyTop + bodyH);
        bodyGrad.addColorStop(0, bodyColor);
        bodyGrad.addColorStop(1, bodyDark);
        ctx.fillStyle = bodyGrad;
        roundRect(-bodyW / 2, bodyTop, bodyW, bodyH, 3);
        ctx.fill();

        // --- HEAD ---
        const headR = 7;
        const headY = bodyTop - headR + 2;

        ctx.fillStyle = skinColor;
        ctx.beginPath();
        ctx.arc(0, headY, headR, 0, Math.PI * 2);
        ctx.fill();

        // --- CAP ---
        ctx.fillStyle = capColor;
        // Cap dome (top half of head)
        ctx.beginPath();
        ctx.arc(0, headY - 1, headR + 1, Math.PI, 0);
        ctx.fill();
        // Cap brim
        ctx.fillRect(-(headR + 3), headY - 1, (headR + 3) * 2, 3);

        // --- EYES ---
        const eyeY = headY + 1;
        if (!player.isBlinking) {
            // Eye whites
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-3, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(3, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils (shifted toward facing direction)
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(-2, eyeY + 0.5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4, eyeY + 0.5, 1.5, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Closed eyes (horizontal lines)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-5, eyeY);
            ctx.lineTo(-1, eyeY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(1, eyeY);
            ctx.lineTo(5, eyeY);
            ctx.stroke();
        }

        // --- MOUTH (small smile) ---
        ctx.strokeStyle = '#c77';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, headY + 4, 2, 0.1, Math.PI - 0.1);
        ctx.stroke();

        ctx.restore();
    }

    function drawPlayerTrail() {
        for (let i = player.trailHistory.length - 1; i >= 0; i--) {
            const t = player.trailHistory[i];
            const alpha = 0.15 * (1 - i / player.trailHistory.length);
            drawPlayerCharacter(t.x, t.y, t.facing, alpha);
        }
    }

    function drawPlayer() {
        drawPlayerTrail();
        drawPlayerCharacter(player.x, player.y, player.facing);
    }

    // ===================== DRAWING: HUD =====================

    function drawHeart(cx, cy, size, color) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(cx, cy + size * 0.3);
        ctx.bezierCurveTo(cx, cy - size * 0.3, cx - size, cy - size * 0.5, cx - size, cy + size * 0.1);
        ctx.bezierCurveTo(cx - size, cy + size * 0.6, cx, cy + size, cx, cy + size);
        ctx.bezierCurveTo(cx, cy + size, cx + size, cy + size * 0.6, cx + size, cy + size * 0.1);
        ctx.bezierCurveTo(cx + size, cy - size * 0.5, cx, cy - size * 0.3, cx, cy + size * 0.3);
        ctx.fill();
        ctx.restore();
    }

    function drawHUD() {
        // Semi-transparent top bar
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, 40);

        // Hearts for lives (left side)
        const heartSize = 8;
        const heartSpacing = 22;
        const maxHearts = Math.min(lives, 15);
        for (let i = 0; i < maxHearts; i++) {
            drawHeart(18 + i * heartSpacing, 18, heartSize, '#ff0000');
        }
        if (lives > 15) {
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('+' + (lives - 15), 18 + 15 * heartSpacing, 20);
        }

        // "LEVEL X" centered
        ctx.fillStyle = '#00ff88';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('LEVEL ' + currentLevel, canvas.width / 2, 20);

        // Coin icon + count (right side)
        ctx.save();
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(canvas.width - 85, 20, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#8B6914';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('$', canvas.width - 85, 21);
        ctx.restore();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(coins + '/' + COINS_FOR_LIFE, canvas.width - 70, 21);
    }

    // ===================== DRAWING: GAME OVER / WIN SCREENS =====================

    function drawGameOverScreen() {
        // Frosted dark overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Radial vignette
        const vigGrad = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 100,
            canvas.width / 2, canvas.height / 2, 400
        );
        vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vigGrad.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isWin = lives > 0;
        const glowColor = isWin ? '#00ff88' : '#ff0000';
        const text = isWin ? 'YOU WIN!' : 'GAME OVER';

        // Glowing text (two passes for extra glow)
        ctx.save();
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 30;
        ctx.fillStyle = glowColor;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 20);
        ctx.restore();

        if (isWin) {
            ctx.fillStyle = '#aaffcc';
            ctx.font = '22px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Congratulations! You beat all 10 levels!', canvas.width / 2, canvas.height / 2 + 30);
        }

        // Pulsing "Press R or Enter" prompt
        const pulse = 0.4 + 0.6 * Math.sin(gameTime * 0.08);
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press R or Enter to restart', canvas.width / 2, canvas.height / 2 + 80);
        ctx.restore();
    }

    // ===================== AMBIENT PARTICLES =====================

    function spawnAmbientParticles() {
        if (frameCount % 10 === 0) {
            spawnParticle({
                x: Math.random() * canvas.width,
                y: canvas.height - Math.random() * 100,
                velX: (Math.random() - 0.5) * 0.3,
                velY: -0.2 - Math.random() * 0.3,
                life: 80 + Math.random() * 60,
                size: 1 + Math.random() * 2,
                color: '#aaccff',
                alpha: 0.25
            });
        }
    }

    // ===================== SCENE DRAWING =====================

    function drawScene() {
        // Draw order: Background -> Stars -> Hills -> Pits -> Platforms -> Spikes -> Coins -> Goal -> Obstacles -> Player
        drawBackground();
        drawStars();
        drawHills();

        const level = levels[currentLevel];

        // Pits
        for (let pit of level.pits) {
            drawPit(pit);
        }

        // Platforms
        for (let p of level.platforms) {
            drawPlatform(p);
        }

        // Spikes
        for (let spike of level.spikes) {
            drawSpike(spike);
        }

        // Coins
        if (level.coins) {
            for (let coin of level.coins) {
                if (!coin.collected) drawCoin(coin);
            }
        }

        // Goal
        drawGoal(level.goal);

        // Moving obstacles
        if (level.movingObstacles) {
            for (let obs of level.movingObstacles) {
                drawMovingObstacle(obs);
            }
        }

        // Player
        drawPlayer();
    }

    // ===================== GAME LOOP =====================

    function gameLoop() {
        frameCount++;
        gameTime++;

        if (deathAnimating) {
            updateDeathAnimation();
            updateParticles();

            ctx.save();
            if (shakeIntensity > 0) {
                const shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
                const shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
                ctx.translate(shakeX, shakeY);
            }

            drawScene();
            drawParticles();
            drawDeathEffects();
            drawHUD();

            ctx.restore();

            requestAnimationFrame(gameLoop);
            return;
        }

        if (!gameOver && !levelComplete) {
            updatePlayer();
            updateMovingObstacles();
            spawnAmbientParticles();
        } else if (levelComplete) {
            if (currentLevel < 10) {
                currentLevel++;
                resetLevel();
            } else {
                gameOver = true;
            }
        }

        updateParticles();
        drawScene();
        drawParticles();
        drawHUD();

        if (gameOver) {
            drawGameOverScreen();
        }

        requestAnimationFrame(gameLoop);
    }

    // Initialize first level
    resetLevel();
    gameLoop();
    </script>
</body>
</html>
