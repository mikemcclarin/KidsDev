<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STELLAR DRIFT</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }
        h1 {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
        }
        canvas {
            display: block;
            margin-bottom: 20px;
            border: 3px solid #0a0a3e;
            touch-action: none;
        }
        #hud {
            display: none;
        }

        /* Mobile: fit canvas to screen, hide title, overlay controls on canvas */
        .mobile-active {
            padding: 0 !important;
            justify-content: flex-start !important;
        }
        .mobile-active h1 {
            display: none;
        }
        .mobile-active canvas {
            margin: 0;
            border: none;
        }

        /* Mobile touch controls */
        #touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            pointer-events: none;
            z-index: 100;
        }
        #touch-controls.visible {
            display: block;
        }
        .touch-btn {
            position: absolute;
            pointer-events: auto;
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 16px;
            background: rgba(0, 255, 255, 0.1);
            color: rgba(0, 255, 255, 0.8);
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            transition: background 0.1s;
        }
        .touch-btn.active {
            background: rgba(0, 255, 255, 0.35);
            border-color: rgba(0, 255, 255, 0.8);
        }
        #btn-left {
            left: 10px;
            bottom: 20px;
            width: 70px;
            height: 70px;
        }
        #btn-right {
            left: 90px;
            bottom: 20px;
            width: 70px;
            height: 70px;
        }
        #btn-jump {
            right: 10px;
            bottom: 20px;
            width: 90px;
            height: 70px;
            font-size: 22px;
        }
        #btn-restart {
            left: 50%;
            transform: translateX(-50%);
            bottom: 20px;
            width: 120px;
            height: 50px;
            font-size: 18px;
            display: none;
        }
        #btn-restart.show {
            display: flex;
        }

        /* Landscape orientation hint */
        #rotate-hint {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            color: #00ffff;
            font-size: 20px;
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }
        #rotate-hint .rotate-icon {
            font-size: 48px;
        }

        @media (max-width: 900px) {
            body { padding: 5px; }
            h1 { font-size: 18px; margin: 4px 0; }
        }

        @media (orientation: portrait) and (max-width: 900px) {
            .mobile-active #rotate-hint {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <h1>STELLAR DRIFT</h1>
    <canvas id="canvas" width="800" height="600"></canvas>

    <!-- Mobile touch controls -->
    <div id="touch-controls">
        <div class="touch-btn" id="btn-left">&larr;</div>
        <div class="touch-btn" id="btn-right">&rarr;</div>
        <div class="touch-btn" id="btn-jump">JUMP</div>
        <div class="touch-btn" id="btn-restart">RESTART</div>
    </div>

    <!-- Rotate to landscape hint -->
    <div id="rotate-hint">
        <div class="rotate-icon">&#x1F4F1;&#x21BB;</div>
        <div>Rotate your device to landscape</div>
    </div>

    <div id="hud">
        <div id="lives">Lives: 10</div>
        <div id="level">Level: 1</div>
        <div id="coins">Crystals: 0/5</div>
        <p style="margin-top: 20px; font-size: 16px;">
            Arrow Keys = Move | Space = Jump (hold for Jetpack)<br>
            Shift = Warp Dash | Collect 5 crystals for an extra life!
        </p>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ===================== INFRASTRUCTURE =====================

    let frameCount = 0;
    let gameTime = 0;

    let particles = [];
    const MAX_PARTICLES = 150;

    function spawnParticle(opts) {
        if (particles.length >= MAX_PARTICLES) return;
        particles.push({
            x: opts.x || 0, y: opts.y || 0,
            velX: opts.velX || 0, velY: opts.velY || 0,
            life: opts.life || 60, maxLife: opts.life || 60,
            size: opts.size || 2, color: opts.color || '#fff',
            alpha: opts.alpha !== undefined ? opts.alpha : 1,
            alphaStart: opts.alpha !== undefined ? opts.alpha : 1,
            shrink: opts.shrink !== undefined ? opts.shrink : true,
            gravity: opts.gravity || 0
        });
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.velX; p.y += p.velY; p.velY += p.gravity; p.life--;
            if (p.shrink) p.alpha = p.alphaStart * (p.life / p.maxLife);
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (let p of particles) {
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            const r = p.size * Math.max(0.2, p.life / p.maxLife);
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    function roundRect(x, y, w, h, r) {
        if (r > w / 2) r = w / 2;
        if (r > h / 2) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    function hash(n) {
        return ((Math.abs(n) * 2654435761) >>> 0) % 1000 / 1000;
    }

    function drawHexagon(cx, cy, r) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = Math.PI / 3 * i - Math.PI / 6;
            const hx = cx + r * Math.cos(angle);
            const hy = cy + r * Math.sin(angle);
            if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
        }
        ctx.closePath();
    }

    // Starfield (150 stars, 3 layers)
    const stars = [];
    for (let layer = 0; layer < 3; layer++) {
        for (let i = 0; i < 50; i++) {
            stars.push({
                x: Math.random() * 800,
                y: Math.random() * 600,
                size: 0.5 + Math.random() * (layer === 0 ? 1.5 : layer === 1 ? 1 : 0.5),
                twinkleSpeed: 0.02 + Math.random() * 0.03,
                twinkleOffset: Math.random() * Math.PI * 2,
                layer: layer
            });
        }
    }

    // Nebulae (pre-generated)
    const nebulae = [
        { x: 150, y: 120, r: 180, color1: 'rgba(80,20,120,0.08)', color2: 'rgba(80,20,120,0)' },
        { x: 600, y: 200, r: 150, color1: 'rgba(20,40,120,0.06)', color2: 'rgba(20,40,120,0)' },
        { x: 400, y: 450, r: 200, color1: 'rgba(60,10,100,0.07)', color2: 'rgba(60,10,100,0)' }
    ];

    // Distant planets
    const distantPlanets = [
        { x: 680, y: 80, r: 25, color1: '#2a1a4a', color2: '#1a0a2a', hasRing: true },
        { x: 120, y: 350, r: 15, color1: '#1a2a4a', color2: '#0a1a3a', hasRing: false }
    ];

    // ===================== GAME STATE =====================

    let lives = 10;
    let currentLevel = 1;
    let gameOver = false;
    let levelComplete = false;
    let coins = 0;
    const COINS_FOR_LIFE = 5;

    // Death animation state
    let deathAnimating = false;
    let deathAnimTimer = 0;
    const DEATH_ANIM_DURATION = 120;
    let shakeIntensity = 0;
    let deathFlashAlpha = 0;
    let deathTextAlpha = 0;
    let deathParticles = [];
    let deathFreezeFrames = 0;

    // Ready countdown state (level transitions only, not death respawn)
    let readyCountdown = 0;
    const READY_DURATION = 120; // 2 seconds at 60fps

    // Powerup state
    const powerups = {
        doubleJump: { active: false, maxAirJumps: 2, airJumpsRemaining: 0 },
        jetpack: { active: false, fuel: 3.0, maxFuel: 3.0, engaged: false, rechargeRate: 1.0 },
        warpDash: { active: false, cooldown: 0, cooldownMax: 90, dashing: false, dashTimer: 0, invincible: false, afterimages: [] },
        shield: { active: false, hits: 1 }
    };

    function resetPowerups() {
        powerups.doubleJump.active = false;
        powerups.doubleJump.airJumpsRemaining = 0;
        powerups.jetpack.active = false;
        powerups.jetpack.fuel = 3.0;
        powerups.jetpack.engaged = false;
        powerups.warpDash.active = false;
        powerups.warpDash.cooldown = 0;
        powerups.warpDash.dashing = false;
        powerups.warpDash.dashTimer = 0;
        powerups.warpDash.invincible = false;
        powerups.warpDash.afterimages = [];
        powerups.shield.active = false;
        powerups.shield.hits = 1;
    }

    function resetAllLevelPickups() {
        for (let key in levels) {
            const lvl = levels[key];
            if (lvl.powerupPickups) {
                for (let p of lvl.powerupPickups) p.collected = false;
            }
        }
    }

    function activatePowerup(type) {
        switch (type) {
            case 'doubleJump':
                powerups.doubleJump.active = true;
                powerups.doubleJump.airJumpsRemaining = powerups.doubleJump.maxAirJumps;
                break;
            case 'jetpack':
                powerups.jetpack.active = true;
                powerups.jetpack.fuel = powerups.jetpack.maxFuel;
                powerups.jetpack.engaged = false;
                break;
            case 'warpDash':
                powerups.warpDash.active = true;
                powerups.warpDash.cooldown = 0;
                break;
            case 'shield':
                powerups.shield.active = true;
                powerups.shield.hits = 1;
                break;
        }
    }

    function getPowerupColor(type) {
        switch (type) {
            case 'doubleJump': return '#00ff88';
            case 'jetpack': return '#ff8800';
            case 'warpDash': return '#00ffff';
            case 'shield': return '#aa44ff';
            default: return '#ffffff';
        }
    }

    // ===================== AUDIO SYSTEM =====================

    let audioCtx = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    function playSound(name) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        switch (name) {
            case 'jump':
                osc.frequency.setValueAtTime(300, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
                break;
            case 'airJump':
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.exponentialRampToValueAtTime(900, t + 0.07);
                gain.gain.setValueAtTime(0.25, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.07);
                osc.start(t); osc.stop(t + 0.07);
                break;
            case 'coin':
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
                break;
            case 'extraLife':
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.15);
                osc.frequency.exponentialRampToValueAtTime(1000, t + 0.3);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(t); osc.stop(t + 0.3);
                break;
            case 'death':
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(t); osc.stop(t + 0.3);
                break;
            case 'levelComplete':
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.setValueAtTime(600, t + 0.1);
                osc.frequency.setValueAtTime(800, t + 0.2);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t); osc.stop(t + 0.4);
                break;
            case 'victory':
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.setValueAtTime(500, t + 0.15);
                osc.frequency.setValueAtTime(600, t + 0.3);
                osc.frequency.setValueAtTime(800, t + 0.45);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                osc.start(t); osc.stop(t + 0.6);
                break;
            case 'powerup':
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                osc.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
                gain.gain.setValueAtTime(0.25, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(t); osc.stop(t + 0.3);
                break;
            case 'warpDash':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(1000, t);
                osc.frequency.exponentialRampToValueAtTime(200, t + 0.15);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t); osc.stop(t + 0.15);
                break;
            case 'shieldBreak':
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, t);
                osc.frequency.setValueAtTime(200, t + 0.05);
                osc.frequency.setValueAtTime(600, t + 0.1);
                osc.frequency.setValueAtTime(100, t + 0.2);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.4);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t); osc.stop(t + 0.4);
                break;
        }
    }

    function playDeathSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;

        const noise = audioCtx.createOscillator();
        const noiseGain = audioCtx.createGain();
        noise.type = 'sawtooth';
        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.frequency.setValueAtTime(200, t);
        noise.frequency.exponentialRampToValueAtTime(40, t + 0.5);
        noiseGain.gain.setValueAtTime(0.5, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
        noise.start(t); noise.stop(t + 0.5);

        const rumble = audioCtx.createOscillator();
        const rumbleGain = audioCtx.createGain();
        rumble.type = 'sine';
        rumble.connect(rumbleGain);
        rumbleGain.connect(audioCtx.destination);
        rumble.frequency.setValueAtTime(60, t);
        rumble.frequency.exponentialRampToValueAtTime(30, t + 0.8);
        rumbleGain.gain.setValueAtTime(0.3, t);
        rumbleGain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
        rumble.start(t); rumble.stop(t + 0.8);

        const tone = audioCtx.createOscillator();
        const toneGain = audioCtx.createGain();
        tone.type = 'square';
        tone.connect(toneGain);
        toneGain.connect(audioCtx.destination);
        tone.frequency.setValueAtTime(500, t + 0.1);
        tone.frequency.exponentialRampToValueAtTime(80, t + 1.0);
        toneGain.gain.setValueAtTime(0.15, t + 0.1);
        toneGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
        tone.start(t + 0.1); tone.stop(t + 1.0);
    }

    // ===================== PLAYER =====================

    const player = {
        x: 50, y: 550, width: 14, height: 18,
        velX: 0, velY: 0, speed: 5,
        jumping: false, startX: 50, startY: 550,
        animFrame: 0, facing: 1,
        squashStretch: 1, wasOnGround: false, onGround: false,
        landTimer: 0, breathPhase: 0, trailHistory: [],
        runPhase: 0, eyeBlinkTimer: 100, isBlinking: false
    };

    // ===================== POWERUP MECHANICS =====================

    function updatePowerups() {
        // Warp dash cooldown & afterimages
        if (powerups.warpDash.cooldown > 0) powerups.warpDash.cooldown--;
        if (powerups.warpDash.dashTimer > 0) {
            powerups.warpDash.dashTimer--;
            if (powerups.warpDash.dashTimer <= 0) powerups.warpDash.invincible = false;
        }
        for (let i = powerups.warpDash.afterimages.length - 1; i >= 0; i--) {
            powerups.warpDash.afterimages[i].life--;
            powerups.warpDash.afterimages[i].alpha *= 0.9;
            if (powerups.warpDash.afterimages[i].life <= 0) powerups.warpDash.afterimages.splice(i, 1);
        }

        // Jetpack
        if (powerups.jetpack.active) {
            if (keys[' '] && !player.onGround && powerups.jetpack.fuel > 0) {
                powerups.jetpack.engaged = true;
                player.velY = Math.max(player.velY - 1.2, -4);
                powerups.jetpack.fuel -= 1 / 60;
                if (powerups.jetpack.fuel < 0) powerups.jetpack.fuel = 0;
                // Flame particles
                if (frameCount % 2 === 0) {
                    const px = player.x + player.width / 2;
                    const py = player.y + player.height;
                    spawnParticle({
                        x: px + (Math.random() - 0.5) * 6, y: py,
                        velX: (Math.random() - 0.5) * 1, velY: 2 + Math.random() * 2,
                        life: 15 + Math.random() * 10, size: 3 + Math.random() * 2,
                        color: Math.random() > 0.5 ? '#ff8800' : '#ffcc00', alpha: 0.8
                    });
                }
            } else {
                powerups.jetpack.engaged = false;
            }
            // Recharge on ground
            if (player.onGround && powerups.jetpack.fuel < powerups.jetpack.maxFuel) {
                powerups.jetpack.fuel += powerups.jetpack.rechargeRate / 60;
                if (powerups.jetpack.fuel > powerups.jetpack.maxFuel) powerups.jetpack.fuel = powerups.jetpack.maxFuel;
            }
        }

        // Double jump: reset air jumps on landing
        if (powerups.doubleJump.active && player.onGround && !player.wasOnGround) {
            powerups.doubleJump.airJumpsRemaining = powerups.doubleJump.maxAirJumps;
        }
    }

    function activateWarpDash() {
        if (!powerups.warpDash.active || powerups.warpDash.cooldown > 0) return;
        const dashDist = 80;
        const startX = player.x;
        const endX = Math.max(0, Math.min(canvas.width - player.width, player.x + dashDist * player.facing));
        // Store afterimages along path
        for (let i = 0; i < 4; i++) {
            const frac = (i + 1) / 5;
            powerups.warpDash.afterimages.push({
                x: startX + (endX - startX) * frac, y: player.y,
                facing: player.facing, alpha: 0.6, life: 15
            });
        }
        player.x = endX;
        powerups.warpDash.cooldown = powerups.warpDash.cooldownMax;
        powerups.warpDash.invincible = true;
        powerups.warpDash.dashTimer = 10;
        // Cyan particles along path
        for (let i = 0; i < 10; i++) {
            const frac = i / 10;
            spawnParticle({
                x: startX + (endX - startX) * frac + (Math.random() - 0.5) * 10,
                y: player.y + player.height / 2 + (Math.random() - 0.5) * 10,
                velX: (Math.random() - 0.5) * 2, velY: (Math.random() - 0.5) * 2,
                life: 20 + Math.random() * 15, size: 2 + Math.random() * 2,
                color: '#00ffff', alpha: 0.7
            });
        }
        playSound('warpDash');
    }

    function spawnAirJumpRings(x, y) {
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            spawnParticle({
                x: x, y: y,
                velX: Math.cos(angle) * 2, velY: Math.sin(angle) * 1.5,
                life: 15 + Math.random() * 10, size: 2,
                color: '#00ffff', alpha: 0.6
            });
        }
    }

    function checkPowerupPickupCollision() {
        const level = levels[currentLevel];
        if (!level.powerupPickups) return;
        const pcx = player.x + player.width / 2;
        const pcy = player.y + player.height / 2;
        for (let pickup of level.powerupPickups) {
            if (pickup.collected) continue;
            const dx = pickup.x - pcx;
            const dy = pickup.y - pcy;
            if (Math.sqrt(dx * dx + dy * dy) < 24) {
                pickup.collected = true;
                activatePowerup(pickup.type);
                playSound('powerup');
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    spawnParticle({
                        x: pickup.x, y: pickup.y,
                        velX: Math.cos(angle) * 3, velY: Math.sin(angle) * 3,
                        life: 25, size: 3, color: getPowerupColor(pickup.type), alpha: 0.8
                    });
                }
            }
        }
    }

    function attemptDeath() {
        // Warp dash invincibility
        if (powerups.warpDash.invincible) return;
        // Shield absorbs hit
        if (powerups.shield.active && powerups.shield.hits > 0) {
            powerups.shield.hits--;
            if (powerups.shield.hits <= 0) powerups.shield.active = false;
            player.velY = -6;
            playSound('shieldBreak');
            for (let i = 0; i < 15; i++) {
                spawnParticle({
                    x: player.x + player.width / 2 + (Math.random() - 0.5) * 20,
                    y: player.y + player.height / 2 + (Math.random() - 0.5) * 20,
                    velX: (Math.random() - 0.5) * 4, velY: (Math.random() - 0.5) * 4,
                    life: 20, size: 2, color: '#aa44ff', alpha: 0.8
                });
            }
            return;
        }
        triggerDeath();
    }

    // ===================== INPUT =====================

    const keys = {};
    window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        initAudio();
        if (e.key === ' ') {
            e.preventDefault();
            if (readyCountdown > 0) { /* blocked during countdown */ }
            else if (!player.jumping) {
                player.velY = -12;
                player.jumping = true;
                playSound('jump');
            } else if (powerups.doubleJump.active && powerups.doubleJump.airJumpsRemaining > 0) {
                powerups.doubleJump.airJumpsRemaining--;
                player.velY = -10;
                playSound('airJump');
                spawnAirJumpRings(player.x + player.width / 2, player.y + player.height);
            }
        }
        if (e.key === 'Shift' && readyCountdown <= 0) {
            e.preventDefault();
            activateWarpDash();
        }
        if ((e.key === 'r' || e.key === 'R' || e.key === 'Enter') && gameOver) {
            e.preventDefault();
            lives = 10;
            currentLevel = 1;
            coins = 0;
            gameOver = false;
            levelComplete = false;
            deathAnimating = false;
            deathParticles = [];
            particles = [];
            readyCountdown = 0;
            resetPowerups();
            resetAllLevelPickups();
            resetLevel();
        }
    });
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // ===================== MOBILE TOUCH CONTROLS =====================

    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    if (isMobile) {
        document.body.classList.add('mobile-active');
        document.getElementById('touch-controls').classList.add('visible');

        // Fill the entire viewport — controls overlay on top of game
        function resizeCanvasToFit() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const gameRatio = 800 / 600;
            let w, h;
            if (vw / vh > gameRatio) {
                h = vh;
                w = h * gameRatio;
            } else {
                w = vw;
                h = w / gameRatio;
            }
            canvas.style.width = Math.floor(w) + 'px';
            canvas.style.height = Math.floor(h) + 'px';
        }
        resizeCanvasToFit();
        window.addEventListener('resize', resizeCanvasToFit);
    }

    function setupTouchButton(id, keyName, options) {
        const btn = document.getElementById(id);
        if (!btn) return;

        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            btn.classList.add('active');
            keys[keyName] = true;
            initAudio();

            // Fire one-shot actions (like keydown does for jump/dash)
            if (options && options.onPress) options.onPress();
        }, { passive: false });

        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            btn.classList.remove('active');
            keys[keyName] = false;
        }, { passive: false });

        btn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            btn.classList.remove('active');
            keys[keyName] = false;
        }, { passive: false });
    }

    setupTouchButton('btn-left', 'ArrowLeft');
    setupTouchButton('btn-right', 'ArrowRight');

    setupTouchButton('btn-jump', ' ', {
        onPress: function() {
            if (readyCountdown > 0) return;
            if (!player.jumping) {
                player.velY = -12;
                player.jumping = true;
                playSound('jump');
            } else if (powerups.doubleJump.active && powerups.doubleJump.airJumpsRemaining > 0) {
                powerups.doubleJump.airJumpsRemaining--;
                player.velY = -10;
                playSound('airJump');
                spawnAirJumpRings(player.x + player.width / 2, player.y + player.height);
            }
        }
    });

    // Restart button — special handling
    const btnRestart = document.getElementById('btn-restart');
    if (btnRestart) {
        btnRestart.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            if (gameOver) {
                lives = 10;
                currentLevel = 1;
                coins = 0;
                gameOver = false;
                levelComplete = false;
                deathAnimating = false;
                deathParticles = [];
                particles = [];
                readyCountdown = 0;
                resetPowerups();
                resetAllLevelPickups();
                resetLevel();
                btnRestart.classList.remove('show');
            }
        }, { passive: false });
    }

    // Prevent all default touch behavior on canvas (scroll, zoom, etc.)
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    // Check orientation on mobile
    function checkOrientation() {
        const hint = document.getElementById('rotate-hint');
        if (!hint || !isMobile) return;
        if (window.innerHeight > window.innerWidth && window.innerWidth < 900) {
            hint.style.display = 'flex';
        } else {
            hint.style.display = 'none';
        }
    }
    if (isMobile) {
        checkOrientation();
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', () => {
            setTimeout(checkOrientation, 200);
        });
    }

    // ===================== LEVELS =====================

    const levels = {
        1: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 100, y: 500, width: 200, height: 20},
                {x: 420, y: 450, width: 200, height: 20},
                {x: 200, y: 400, width: 150, height: 20},
                {x: 500, y: 350, width: 150, height: 20}
            ],
            pits: [{x: 350, y: 520, width: 80, height: 60}],
            spikes: [{x: 600, y: 560, width: 80, height: 40}],
            coins: [
                {x: 150, y: 470, collected: false},
                {x: 520, y: 420, collected: false}
            ],
            movingObstacles: [],
            powerupPickups: [],
            goal: {x: 750, y: 500, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        2: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 50, y: 530, width: 120, height: 20},
                {x: 200, y: 480, width: 120, height: 20},
                {x: 350, y: 430, width: 120, height: 20},
                {x: 500, y: 380, width: 120, height: 20},
                {x: 650, y: 330, width: 150, height: 20}
            ],
            pits: [
                {x: 150, y: 540, width: 50, height: 60},
                {x: 300, y: 490, width: 50, height: 60},
                {x: 450, y: 440, width: 50, height: 60},
                {x: 600, y: 390, width: 50, height: 60}
            ],
            spikes: [
                {x: 100, y: 560, width: 40, height: 40},
                {x: 250, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 85, y: 500, collected: false},
                {x: 235, y: 450, collected: false},
                {x: 385, y: 400, collected: false},
                {x: 700, y: 300, collected: false}
            ],
            movingObstacles: [],
            powerupPickups: [],
            goal: {x: 740, y: 250, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        3: {
            platforms: [
                {x: 0, y: 580, width: 150, height: 20},
                {x: 200, y: 530, width: 100, height: 20},
                {x: 350, y: 480, width: 100, height: 20},
                {x: 500, y: 430, width: 100, height: 20},
                {x: 650, y: 380, width: 150, height: 20}
            ],
            pits: [
                {x: 150, y: 540, width: 50, height: 60},
                {x: 450, y: 440, width: 50, height: 60}
            ],
            spikes: [
                {x: 300, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 240, y: 500, collected: false},
                {x: 540, y: 400, collected: false}
            ],
            movingObstacles: [],
            powerupPickups: [],
            goal: {x: 740, y: 300, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        4: {
            platforms: [
                {x: 0, y: 580, width: 200, height: 20},
                {x: 250, y: 520, width: 150, height: 20},
                {x: 450, y: 460, width: 150, height: 20},
                {x: 650, y: 400, width: 150, height: 20}
            ],
            pits: [{x: 200, y: 540, width: 50, height: 60}],
            spikes: [{x: 350, y: 560, width: 40, height: 40}],
            coins: [
                {x: 300, y: 490, collected: false},
                {x: 700, y: 370, collected: false}
            ],
            movingObstacles: [
                {x: 480, y: 430, width: 30, height: 30, startX: 450, endX: 570, speed: 2, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 100, y: 555, type: 'doubleJump', collected: false}
            ],
            goal: {x: 750, y: 320, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        5: {
            platforms: [
                {x: 0, y: 580, width: 150, height: 20},
                {x: 50, y: 500, width: 100, height: 20},
                {x: 180, y: 420, width: 100, height: 20},
                {x: 320, y: 340, width: 100, height: 20},
                {x: 460, y: 260, width: 100, height: 20},
                {x: 600, y: 180, width: 200, height: 20}
            ],
            pits: [],
            spikes: [
                {x: 200, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 220, y: 390, collected: false},
                {x: 360, y: 310, collected: false},
                {x: 500, y: 230, collected: false}
            ],
            movingObstacles: [
                {x: 620, y: 120, width: 30, height: 30, startY: 100, endY: 150, speed: 1.5, direction: 1, type: 'vertical'}
            ],
            powerupPickups: [
                {x: 75, y: 555, type: 'shield', collected: false}
            ],
            goal: {x: 740, y: 100, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        6: {
            platforms: [
                {x: 0, y: 580, width: 120, height: 20},
                {x: 170, y: 520, width: 120, height: 20},
                {x: 50, y: 440, width: 120, height: 20},
                {x: 220, y: 360, width: 120, height: 20},
                {x: 400, y: 300, width: 120, height: 20},
                {x: 570, y: 240, width: 120, height: 20},
                {x: 650, y: 400, width: 100, height: 20}
            ],
            pits: [{x: 120, y: 540, width: 50, height: 60}],
            spikes: [
                {x: 300, y: 560, width: 40, height: 40},
                {x: 500, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 90, y: 410, collected: false},
                {x: 260, y: 330, collected: false},
                {x: 610, y: 210, collected: false}
            ],
            movingObstacles: [
                {x: 430, y: 270, width: 30, height: 30, startX: 400, endX: 490, speed: 2, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 200, y: 495, type: 'warpDash', collected: false}
            ],
            goal: {x: 700, y: 320, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        7: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 150, y: 520, width: 100, height: 20},
                {x: 300, y: 460, width: 100, height: 20},
                {x: 450, y: 400, width: 100, height: 20},
                {x: 300, y: 320, width: 100, height: 20},
                {x: 500, y: 260, width: 100, height: 20},
                {x: 650, y: 200, width: 150, height: 20}
            ],
            pits: [
                {x: 100, y: 540, width: 50, height: 60},
                {x: 250, y: 480, width: 50, height: 60}
            ],
            spikes: [
                {x: 400, y: 560, width: 40, height: 40},
                {x: 600, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 190, y: 490, collected: false},
                {x: 340, y: 430, collected: false},
                {x: 540, y: 230, collected: false}
            ],
            movingObstacles: [
                {x: 320, y: 290, width: 25, height: 25, startX: 300, endX: 375, speed: 2, direction: 1, type: 'horizontal'},
                {x: 680, y: 130, width: 25, height: 25, startY: 120, endY: 170, speed: 1.5, direction: 1, type: 'vertical'}
            ],
            powerupPickups: [
                {x: 50, y: 555, type: 'jetpack', collected: false}
            ],
            goal: {x: 740, y: 120, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        8: {
            platforms: [
                {x: 0, y: 580, width: 80, height: 20},
                {x: 120, y: 530, width: 80, height: 20},
                {x: 240, y: 480, width: 80, height: 20},
                {x: 360, y: 430, width: 80, height: 20},
                {x: 480, y: 380, width: 80, height: 20},
                {x: 600, y: 330, width: 80, height: 20},
                {x: 700, y: 280, width: 100, height: 20}
            ],
            pits: [
                {x: 80, y: 540, width: 40, height: 60},
                {x: 320, y: 440, width: 40, height: 60}
            ],
            spikes: [
                {x: 200, y: 560, width: 30, height: 30},
                {x: 440, y: 560, width: 30, height: 30},
                {x: 560, y: 560, width: 30, height: 30}
            ],
            coins: [
                {x: 150, y: 500, collected: false},
                {x: 270, y: 450, collected: false},
                {x: 390, y: 400, collected: false},
                {x: 630, y: 300, collected: false}
            ],
            movingObstacles: [
                {x: 500, y: 350, width: 25, height: 25, startX: 480, endX: 535, speed: 2.5, direction: 1, type: 'horizontal'},
                {x: 720, y: 220, width: 25, height: 25, startY: 200, endY: 250, speed: 2, direction: 1, type: 'vertical'}
            ],
            powerupPickups: [
                {x: 40, y: 555, type: 'doubleJump', collected: false},
                {x: 400, y: 405, type: 'shield', collected: false}
            ],
            goal: {x: 740, y: 200, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        },
        9: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 80, y: 500, width: 80, height: 20},
                {x: 200, y: 430, width: 80, height: 20},
                {x: 320, y: 360, width: 80, height: 20},
                {x: 200, y: 280, width: 80, height: 20},
                {x: 350, y: 210, width: 80, height: 20},
                {x: 500, y: 150, width: 80, height: 20},
                {x: 650, y: 100, width: 150, height: 20}
            ],
            pits: [{x: 160, y: 540, width: 40, height: 60}],
            spikes: [
                {x: 250, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40},
                {x: 550, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 110, y: 470, collected: false},
                {x: 230, y: 400, collected: false},
                {x: 230, y: 250, collected: false},
                {x: 530, y: 120, collected: false}
            ],
            movingObstacles: [
                {x: 340, y: 330, width: 25, height: 25, startX: 320, endX: 375, speed: 2, direction: 1, type: 'horizontal'},
                {x: 220, y: 250, width: 25, height: 25, startY: 200, endY: 250, speed: 1.5, direction: 1, type: 'vertical'},
                {x: 520, y: 100, width: 25, height: 25, startX: 500, endX: 555, speed: 2.5, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 50, y: 555, type: 'warpDash', collected: false},
                {x: 360, y: 335, type: 'jetpack', collected: false}
            ],
            goal: {x: 740, y: 20, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        10: {
            platforms: [
                {x: 0, y: 580, width: 80, height: 20},
                {x: 130, y: 530, width: 70, height: 20},
                {x: 250, y: 480, width: 70, height: 20},
                {x: 130, y: 400, width: 70, height: 20},
                {x: 250, y: 330, width: 70, height: 20},
                {x: 380, y: 280, width: 70, height: 20},
                {x: 510, y: 220, width: 70, height: 20},
                {x: 380, y: 150, width: 70, height: 20},
                {x: 550, y: 100, width: 70, height: 20},
                {x: 680, y: 60, width: 120, height: 20}
            ],
            pits: [
                {x: 80, y: 540, width: 50, height: 60},
                {x: 200, y: 490, width: 50, height: 60}
            ],
            spikes: [
                {x: 320, y: 560, width: 40, height: 40},
                {x: 450, y: 560, width: 40, height: 40},
                {x: 600, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 155, y: 500, collected: false},
                {x: 155, y: 370, collected: false},
                {x: 280, y: 300, collected: false},
                {x: 540, y: 190, collected: false},
                {x: 720, y: 30, collected: false}
            ],
            movingObstacles: [
                {x: 270, y: 450, width: 25, height: 25, startX: 250, endX: 295, speed: 2, direction: 1, type: 'horizontal'},
                {x: 270, y: 300, width: 25, height: 25, startX: 250, endX: 295, speed: 2.5, direction: -1, type: 'horizontal'},
                {x: 400, y: 250, width: 25, height: 25, startX: 380, endX: 425, speed: 2, direction: 1, type: 'horizontal'},
                {x: 580, y: 50, width: 25, height: 25, startY: 30, endY: 70, speed: 2, direction: 1, type: 'vertical'}
            ],
            powerupPickups: [
                {x: 40, y: 555, type: 'doubleJump', collected: false},
                {x: 280, y: 455, type: 'shield', collected: false},
                {x: 400, y: 250, type: 'warpDash', collected: false}
            ],
            goal: {x: 740, y: -20, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        },
        // ===== NEW LEVELS 11-15 =====
        11: {
            platforms: [
                {x: 0, y: 580, width: 120, height: 20},
                {x: 180, y: 520, width: 80, height: 20},
                {x: 80, y: 440, width: 80, height: 20},
                {x: 220, y: 360, width: 80, height: 20},
                {x: 100, y: 280, width: 80, height: 20},
                {x: 280, y: 200, width: 80, height: 20},
                {x: 450, y: 150, width: 100, height: 20},
                {x: 600, y: 100, width: 120, height: 20}
            ],
            pits: [{x: 120, y: 540, width: 60, height: 60}],
            spikes: [
                {x: 300, y: 560, width: 40, height: 40},
                {x: 400, y: 560, width: 40, height: 40},
                {x: 500, y: 560, width: 40, height: 40}
            ],
            coins: [
                {x: 210, y: 490, collected: false},
                {x: 140, y: 410, collected: false},
                {x: 260, y: 330, collected: false},
                {x: 490, y: 120, collected: false}
            ],
            movingObstacles: [
                {x: 240, y: 330, width: 25, height: 25, startX: 220, endX: 280, speed: 2, direction: 1, type: 'horizontal'},
                {x: 300, y: 170, width: 25, height: 25, startY: 150, endY: 190, speed: 1.5, direction: 1, type: 'vertical'},
                {x: 620, y: 60, width: 25, height: 25, startX: 600, endX: 690, speed: 2.5, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 60, y: 555, type: 'doubleJump', collected: false},
                {x: 480, y: 125, type: 'shield', collected: false}
            ],
            goal: {x: 680, y: 20, width: 40, height: 80},
            playerStart: {x: 50, y: 550}
        },
        12: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 200, y: 530, width: 80, height: 20},
                {x: 380, y: 530, width: 80, height: 20},
                {x: 560, y: 530, width: 80, height: 20},
                {x: 560, y: 400, width: 80, height: 20},
                {x: 380, y: 320, width: 80, height: 20},
                {x: 200, y: 250, width: 80, height: 20},
                {x: 400, y: 180, width: 80, height: 20},
                {x: 600, y: 120, width: 120, height: 20}
            ],
            pits: [
                {x: 100, y: 540, width: 100, height: 60},
                {x: 460, y: 540, width: 100, height: 60}
            ],
            spikes: [
                {x: 280, y: 560, width: 30, height: 30},
                {x: 640, y: 560, width: 30, height: 30},
                {x: 460, y: 300, width: 30, height: 30},
                {x: 280, y: 230, width: 30, height: 30}
            ],
            coins: [
                {x: 240, y: 500, collected: false},
                {x: 420, y: 500, collected: false},
                {x: 600, y: 370, collected: false},
                {x: 440, y: 150, collected: false}
            ],
            movingObstacles: [
                {x: 580, y: 470, width: 25, height: 25, startY: 410, endY: 500, speed: 2, direction: 1, type: 'vertical'},
                {x: 220, y: 220, width: 25, height: 25, startX: 200, endX: 260, speed: 2, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 50, y: 555, type: 'jetpack', collected: false},
                {x: 600, y: 505, type: 'warpDash', collected: false}
            ],
            goal: {x: 680, y: 40, width: 40, height: 80},
            playerStart: {x: 40, y: 550}
        },
        13: {
            platforms: [
                {x: 0, y: 580, width: 100, height: 20},
                {x: 140, y: 530, width: 60, height: 20},
                {x: 140, y: 420, width: 60, height: 20},
                {x: 260, y: 360, width: 80, height: 20},
                {x: 400, y: 360, width: 60, height: 20},
                {x: 400, y: 250, width: 60, height: 20},
                {x: 520, y: 200, width: 60, height: 20},
                {x: 650, y: 140, width: 60, height: 20},
                {x: 650, y: 580, width: 60, height: 20},
                {x: 700, y: 60, width: 100, height: 20}
            ],
            pits: [
                {x: 100, y: 540, width: 40, height: 60},
                {x: 340, y: 540, width: 40, height: 60}
            ],
            spikes: [
                {x: 200, y: 560, width: 30, height: 30},
                {x: 460, y: 340, width: 30, height: 30},
                {x: 580, y: 180, width: 30, height: 30}
            ],
            coins: [
                {x: 160, y: 500, collected: false},
                {x: 290, y: 330, collected: false},
                {x: 540, y: 170, collected: false},
                {x: 740, y: 30, collected: false}
            ],
            movingObstacles: [
                {x: 280, y: 330, width: 25, height: 25, startX: 260, endX: 315, speed: 2, direction: 1, type: 'horizontal'},
                {x: 670, y: 110, width: 25, height: 25, startY: 70, endY: 120, speed: 2, direction: 1, type: 'vertical'}
            ],
            powerupPickups: [
                {x: 50, y: 555, type: 'doubleJump', collected: false},
                {x: 300, y: 335, type: 'warpDash', collected: false},
                {x: 420, y: 225, type: 'jetpack', collected: false},
                {x: 670, y: 555, type: 'shield', collected: false}
            ],
            goal: {x: 740, y: -20, width: 40, height: 80},
            playerStart: {x: 40, y: 550}
        },
        14: {
            platforms: [
                {x: 0, y: 580, width: 80, height: 20},
                {x: 130, y: 530, width: 50, height: 20},
                {x: 230, y: 470, width: 50, height: 20},
                {x: 130, y: 400, width: 50, height: 20},
                {x: 280, y: 340, width: 50, height: 20},
                {x: 420, y: 290, width: 50, height: 20},
                {x: 300, y: 220, width: 50, height: 20},
                {x: 460, y: 160, width: 50, height: 20},
                {x: 580, y: 110, width: 50, height: 20},
                {x: 680, y: 60, width: 120, height: 20}
            ],
            pits: [
                {x: 80, y: 540, width: 50, height: 60},
                {x: 180, y: 480, width: 50, height: 60}
            ],
            spikes: [
                {x: 330, y: 560, width: 30, height: 30},
                {x: 360, y: 320, width: 30, height: 30},
                {x: 510, y: 140, width: 30, height: 30},
                {x: 630, y: 90, width: 30, height: 30}
            ],
            coins: [
                {x: 150, y: 500, collected: false},
                {x: 250, y: 440, collected: false},
                {x: 440, y: 260, collected: false},
                {x: 600, y: 80, collected: false},
                {x: 740, y: 30, collected: false}
            ],
            movingObstacles: [
                {x: 150, y: 370, width: 25, height: 25, startX: 130, endX: 170, speed: 2.5, direction: 1, type: 'horizontal'},
                {x: 300, y: 310, width: 25, height: 25, startX: 280, endX: 315, speed: 2, direction: 1, type: 'horizontal'},
                {x: 440, y: 260, width: 25, height: 25, startY: 170, endY: 270, speed: 2, direction: 1, type: 'vertical'},
                {x: 700, y: 30, width: 25, height: 25, startX: 680, endX: 770, speed: 2.5, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 40, y: 555, type: 'doubleJump', collected: false},
                {x: 160, y: 375, type: 'warpDash', collected: false},
                {x: 310, y: 195, type: 'jetpack', collected: false},
                {x: 500, y: 85, type: 'shield', collected: false}
            ],
            goal: {x: 740, y: -20, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        },
        15: {
            platforms: [
                {x: 0, y: 580, width: 140, height: 20},
                {x: 200, y: 530, width: 60, height: 20},
                {x: 320, y: 480, width: 60, height: 20},
                {x: 200, y: 410, width: 60, height: 20},
                {x: 370, y: 350, width: 60, height: 20},
                {x: 510, y: 300, width: 60, height: 20},
                {x: 370, y: 230, width: 60, height: 20},
                {x: 510, y: 170, width: 60, height: 20},
                {x: 220, y: 130, width: 60, height: 20},
                {x: 400, y: 80, width: 60, height: 20},
                {x: 600, y: 50, width: 120, height: 20}
            ],
            pits: [
                {x: 140, y: 540, width: 60, height: 60},
                {x: 260, y: 490, width: 60, height: 60}
            ],
            spikes: [
                {x: 400, y: 560, width: 30, height: 30},
                {x: 500, y: 560, width: 30, height: 30},
                {x: 600, y: 560, width: 30, height: 30},
                {x: 440, y: 320, width: 30, height: 30},
                {x: 270, y: 200, width: 30, height: 30}
            ],
            coins: [
                {x: 230, y: 500, collected: false},
                {x: 350, y: 450, collected: false},
                {x: 240, y: 380, collected: false},
                {x: 540, y: 270, collected: false},
                {x: 540, y: 140, collected: false}
            ],
            movingObstacles: [
                {x: 340, y: 450, width: 25, height: 25, startX: 320, endX: 365, speed: 2.5, direction: 1, type: 'horizontal'},
                {x: 220, y: 380, width: 25, height: 25, startY: 350, endY: 400, speed: 2, direction: 1, type: 'vertical'},
                {x: 390, y: 320, width: 25, height: 25, startX: 370, endX: 415, speed: 2, direction: 1, type: 'horizontal'},
                {x: 530, y: 240, width: 25, height: 25, startY: 180, endY: 280, speed: 2, direction: 1, type: 'vertical'},
                {x: 240, y: 100, width: 25, height: 25, startX: 220, endX: 270, speed: 2.5, direction: 1, type: 'horizontal'},
                {x: 640, y: 20, width: 25, height: 25, startX: 600, endX: 690, speed: 2, direction: 1, type: 'horizontal'}
            ],
            powerupPickups: [
                {x: 30, y: 555, type: 'doubleJump', collected: false},
                {x: 60, y: 555, type: 'jetpack', collected: false},
                {x: 90, y: 555, type: 'warpDash', collected: false},
                {x: 120, y: 555, type: 'shield', collected: false}
            ],
            goal: {x: 660, y: -30, width: 40, height: 80},
            playerStart: {x: 30, y: 550}
        }
    };

    // ===================== LEVEL MANAGEMENT =====================

    function resetLevelPickups() {
        const level = levels[currentLevel];
        if (level.coins) {
            for (let coin of level.coins) coin.collected = false;
        }
        if (level.powerupPickups) {
            for (let p of level.powerupPickups) p.collected = false;
        }
    }

    function resetLevel(died) {
        const level = levels[currentLevel];
        player.x = level.playerStart.x;
        player.y = level.playerStart.y;
        player.startX = level.playerStart.x;
        player.startY = level.playerStart.y;
        player.velX = 0;
        player.velY = 0;
        player.jumping = false;
        player.squashStretch = 1;
        player.wasOnGround = false;
        player.onGround = false;
        player.landTimer = 0;
        player.breathPhase = 0;
        player.trailHistory = [];
        player.runPhase = 0;
        player.eyeBlinkTimer = 100;
        player.isBlinking = false;
        levelComplete = false;
        if (died) {
            coins = 0;
            resetPowerups();
        }
        particles = [];
        resetLevelPickups();
    }

    // ===================== DEATH SYSTEM =====================

    function spawnDeathParticles(x, y) {
        deathParticles = [];
        for (let i = 0; i < 20; i++) {
            deathParticles.push({
                x: x, y: y,
                velX: (Math.random() - 0.5) * 8,
                velY: (Math.random() - 0.5) * 8 - 3,
                life: 60 + Math.random() * 40,
                size: 2 + Math.random() * 4,
                color: Math.random() > 0.5 ? '#ff0000' : '#ffff00'
            });
        }
    }

    function triggerDeath() {
        lives--;
        playDeathSound();
        deathAnimating = true;
        deathAnimTimer = 0;
        shakeIntensity = 12;
        deathFlashAlpha = 1.0;
        deathTextAlpha = 0;
        deathFreezeFrames = 10;
        spawnDeathParticles(player.x + player.width / 2, player.y + player.height / 2);
    }

    function updateDeathAnimation() {
        if (deathFreezeFrames > 0) {
            deathFreezeFrames--;
            return;
        }

        deathAnimTimer++;
        shakeIntensity = Math.max(0, 12 * (1 - deathAnimTimer / 40));
        deathFlashAlpha = Math.max(0, 1.0 - deathAnimTimer / 15);

        if (deathAnimTimer > 15 && deathAnimTimer < 100) {
            deathTextAlpha = Math.min(1, deathTextAlpha + 0.08);
        } else if (deathAnimTimer >= 100) {
            deathTextAlpha = Math.max(0, deathTextAlpha - 0.05);
        }

        for (let p of deathParticles) {
            p.x += p.velX;
            p.y += p.velY;
            p.velY += 0.15;
            p.life--;
            p.size *= 0.98;
        }
        deathParticles = deathParticles.filter(p => p.life > 0);

        if (deathAnimTimer >= DEATH_ANIM_DURATION) {
            deathAnimating = false;
            deathTextAlpha = 0;
            deathFlashAlpha = 0;
            shakeIntensity = 0;
            deathParticles = [];
            if (lives <= 0) {
                gameOver = true;
            } else {
                resetLevel(true);
            }
        }
    }

    function drawDeathEffects() {
        if (deathFlashAlpha > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${deathFlashAlpha * 0.6})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        for (let p of deathParticles) {
            ctx.globalAlpha = Math.min(1, p.life / 20);
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        }
        ctx.globalAlpha = 1;

        if (deathTextAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = deathTextAlpha;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, canvas.height / 2 - 60, canvas.width, 120);
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('YOU DIED', canvas.width / 2, canvas.height / 2 + 10);
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ff4444';
            ctx.fillText('YOU DIED', canvas.width / 2, canvas.height / 2 + 10);
            ctx.restore();
        }
    }

    // ===================== COLLISION =====================

    function checkCoinCollision() {
        const level = levels[currentLevel];
        if (!level.coins) return;

        for (let coin of level.coins) {
            if (coin.collected) continue;

            const coinCenterX = coin.x + 10;
            const coinCenterY = coin.y + 10;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            const dx = coinCenterX - playerCenterX;
            const dy = coinCenterY - playerCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 10 + player.width / 2 + 6) {
                coin.collected = true;
                coins++;
                playSound('coin');

                if (coins >= COINS_FOR_LIFE) {
                    coins = 0;
                    lives++;
                    playSound('extraLife');
                }
            }
        }
    }

    function updateMovingObstacles() {
        const level = levels[currentLevel];
        if (!level.movingObstacles) return;

        for (let obs of level.movingObstacles) {
            if (obs.type === 'horizontal') {
                obs.x += obs.speed * obs.direction;
                if (obs.x <= obs.startX || obs.x + obs.width >= obs.endX + obs.width) {
                    obs.direction *= -1;
                }
            } else if (obs.type === 'vertical') {
                obs.y += obs.speed * obs.direction;
                if (obs.y <= obs.startY || obs.y + obs.height >= obs.endY + obs.height) {
                    obs.direction *= -1;
                }
            }
        }
    }

    function checkMovingObstacleCollision() {
        const level = levels[currentLevel];
        if (!level.movingObstacles) return false;

        for (let obs of level.movingObstacles) {
            if (
                player.x + player.width > obs.x &&
                player.x < obs.x + obs.width &&
                player.y + player.height > obs.y &&
                player.y < obs.y + obs.height
            ) {
                return true;
            }
        }
        return false;
    }

    // ===================== PLAYER UPDATE =====================

    function updatePlayer() {
        player.wasOnGround = player.onGround;

        player.velX = 0;
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            player.velX = -player.speed;
            player.facing = -1;
        }
        if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            player.velX = player.speed;
            player.facing = 1;
        }

        player.x += player.velX;

        // Gravity
        player.velY += 0.8;
        player.y += player.velY;

        // Boundary check
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

        // Platform collision
        let onPlatform = false;
        const level = levels[currentLevel];
        for (let platform of level.platforms) {
            if (
                player.velY >= 0 &&
                player.y + player.height <= platform.y + 5 &&
                player.y + player.height + player.velY >= platform.y &&
                player.x + player.width > platform.x &&
                player.x < platform.x + platform.width
            ) {
                player.y = platform.y - player.height;
                player.velY = 0;
                player.jumping = false;
                onPlatform = true;
            }
        }

        player.onGround = onPlatform;

        // Update powerups
        updatePowerups();

        // Pit collision
        for (let pit of level.pits) {
            if (
                player.x + player.width > pit.x &&
                player.x < pit.x + pit.width &&
                player.y + player.height > pit.y &&
                player.y < pit.y + pit.height
            ) {
                attemptDeath();
                return;
            }
        }

        // Spike collision
        for (let spike of level.spikes) {
            if (
                player.x + player.width > spike.x &&
                player.x < spike.x + spike.width &&
                player.y + player.height > spike.y &&
                player.y < spike.y + spike.height
            ) {
                attemptDeath();
                return;
            }
        }

        // Moving obstacle collision
        if (checkMovingObstacleCollision()) {
            attemptDeath();
            return;
        }

        // Fall into void - always kills (no shield save)
        if (player.y > canvas.height) {
            triggerDeath();
            return;
        }

        // Coin collision
        checkCoinCollision();

        // Powerup pickup collision
        checkPowerupPickupCollision();

        // Goal collision
        if (
            player.x + player.width > level.goal.x &&
            player.x < level.goal.x + level.goal.width &&
            player.y + player.height > level.goal.y &&
            player.y < level.goal.y + level.goal.height
        ) {
            levelComplete = true;
            if (currentLevel < 15) {
                playSound('levelComplete');
            } else {
                playSound('victory');
            }
        }

        // --- Animation state updates ---

        if (player.onGround && !player.wasOnGround) {
            player.squashStretch = 0.7;
            player.landTimer = 8;
        }
        if (player.landTimer > 0) {
            player.landTimer--;
            player.squashStretch += (1 - player.squashStretch) * 0.3;
        }

        if (player.velY < -5) {
            player.squashStretch = 1.3;
        } else if (player.onGround && player.landTimer <= 0) {
            player.squashStretch += (1 - player.squashStretch) * 0.2;
        }

        player.breathPhase += 0.03;

        if (Math.abs(player.velX) > 0.5 && player.onGround) {
            player.runPhase += 0.3;
        }

        player.eyeBlinkTimer--;
        if (player.eyeBlinkTimer <= 0) {
            if (player.isBlinking) {
                player.isBlinking = false;
                player.eyeBlinkTimer = 120 + Math.floor(Math.random() * 180);
            } else {
                player.isBlinking = true;
                player.eyeBlinkTimer = 6;
            }
        }

        if (Math.abs(player.velX) > 1 || Math.abs(player.velY) > 1) {
            player.trailHistory.unshift({x: player.x, y: player.y, facing: player.facing});
            if (player.trailHistory.length > 5) player.trailHistory.pop();
        } else {
            player.trailHistory = [];
        }

        if (onPlatform && player.velX !== 0) {
            player.animFrame = (player.animFrame + 0.15) % 2;
        } else {
            player.animFrame = 0;
        }
    }

    // ===================== DRAWING: BACKGROUND =====================

    function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#050510');
        grad.addColorStop(0.35, '#0a0a30');
        grad.addColorStop(0.65, '#1a0a3a');
        grad.addColorStop(1, '#0a1535');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Nebulae
        for (let n of nebulae) {
            const ng = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
            ng.addColorStop(0, n.color1);
            ng.addColorStop(1, n.color2);
            ctx.fillStyle = ng;
            ctx.fillRect(n.x - n.r, n.y - n.r, n.r * 2, n.r * 2);
        }
    }

    function drawStars() {
        const parallaxBase = player.x / canvas.width;
        for (let star of stars) {
            const twinkle = 0.4 + 0.6 * Math.sin(gameTime * star.twinkleSpeed + star.twinkleOffset);
            const shift = (star.layer === 0 ? 10 : star.layer === 1 ? 5 : 2) * parallaxBase;
            const sx = ((star.x - shift) % 800 + 800) % 800;
            ctx.globalAlpha = twinkle * 0.8;
            ctx.fillStyle = star.layer === 2 ? '#aaccff' : '#fff';
            ctx.beginPath();
            ctx.arc(sx, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Distant planets
        for (let p of distantPlanets) {
            const pg = ctx.createRadialGradient(p.x - p.r * 0.3, p.y - p.r * 0.3, p.r * 0.1, p.x, p.y, p.r);
            pg.addColorStop(0, p.color1);
            pg.addColorStop(1, p.color2);
            ctx.fillStyle = pg;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
            if (p.hasRing) {
                ctx.save();
                ctx.strokeStyle = 'rgba(100,80,140,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, p.r * 1.8, p.r * 0.4, 0.3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }
    }

    // Pre-generated space battle elements (seeded per level range)
    const battleCruisers = [
        { x: 620, y: 45, len: 40, angle: 0.15 },
        { x: 180, y: 70, len: 35, angle: -0.1 },
        { x: 400, y: 30, len: 50, angle: 0.05 }
    ];
    const battleFighters = [];
    for (let i = 0; i < 12; i++) {
        battleFighters.push({
            x: 80 + (i * 67) % 700,
            y: 20 + (i * 43) % 80,
            size: 2 + (i % 3),
            speed: 0.3 + (i % 4) * 0.15,
            angle: ((i * 137) % 360) * Math.PI / 180,
            orbit: 15 + (i % 3) * 10
        });
    }

    function drawSpaceBattle() {
        if (currentLevel < 6) return;
        const intensity = Math.min(1, (currentLevel - 5) / 5); // 0 at L5, 1 at L10+
        const alpha = 0.15 + intensity * 0.2;

        ctx.save();
        ctx.globalAlpha = alpha;

        // Draw cruisers - elongated hull shapes
        for (let ci = 0; ci < Math.min(battleCruisers.length, 1 + Math.floor(intensity * 2)); ci++) {
            const c = battleCruisers[ci];
            const drift = Math.sin(gameTime * 0.005 + ci * 2) * 8;
            const cx = c.x + drift;
            const cy = c.y;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(c.angle);

            // Hull
            ctx.fillStyle = '#1a1a3a';
            ctx.strokeStyle = 'rgba(80,100,180,0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-c.len / 2, 0);
            ctx.lineTo(-c.len / 4, -4);
            ctx.lineTo(c.len / 3, -3);
            ctx.lineTo(c.len / 2, 0);
            ctx.lineTo(c.len / 3, 3);
            ctx.lineTo(-c.len / 4, 4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Engine glow
            ctx.fillStyle = 'rgba(100,150,255,0.6)';
            ctx.beginPath();
            ctx.arc(-c.len / 2 - 2, 0, 2, 0, Math.PI * 2);
            ctx.fill();

            // Bridge lights
            ctx.fillStyle = 'rgba(200,220,255,0.5)';
            ctx.fillRect(c.len / 6, -1, 4, 2);

            ctx.restore();
        }

        // Draw fighters - small triangles orbiting/moving
        const numFighters = Math.floor(3 + intensity * 9);
        for (let fi = 0; fi < numFighters && fi < battleFighters.length; fi++) {
            const f = battleFighters[fi];
            const t = gameTime * f.speed * 0.02;
            const fx = f.x + Math.cos(t + f.angle) * f.orbit;
            const fy = f.y + Math.sin(t + f.angle) * f.orbit * 0.4;
            const moveAngle = Math.atan2(
                Math.cos(t + f.angle + 0.1) * f.orbit * 0.4 - Math.sin(t + f.angle) * f.orbit * 0.4,
                -Math.sin(t + f.angle + 0.1) * f.orbit - Math.cos(t + f.angle) * f.orbit
            );

            ctx.save();
            ctx.translate(fx, fy);
            ctx.rotate(moveAngle);
            ctx.fillStyle = fi % 2 === 0 ? '#2a2a50' : '#3a2030';
            ctx.beginPath();
            ctx.moveTo(f.size, 0);
            ctx.lineTo(-f.size, -f.size * 0.6);
            ctx.lineTo(-f.size * 0.5, 0);
            ctx.lineTo(-f.size, f.size * 0.6);
            ctx.closePath();
            ctx.fill();

            // Tiny engine dot
            ctx.fillStyle = fi % 2 === 0 ? 'rgba(100,150,255,0.7)' : 'rgba(255,100,50,0.7)';
            ctx.beginPath();
            ctx.arc(-f.size * 0.5, 0, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Laser fire - chaotic, random-feeling using prime-based hashing
        const laserSlots = Math.floor(8 + intensity * 12);
        for (let li = 0; li < laserSlots; li++) {
            // Use primes to break up repeating patterns
            const t1 = gameTime * (0.7 + li * 0.31);
            const phase = ((t1 * 7 + li * 1301) % 500) | 0;
            if (phase > 25) continue; // Brief flash window

            const laserAlpha = (1 - phase / 25) * 0.7;

            // Randomized origin - pick from cruisers, fighters, or arbitrary points
            const h1 = hash(li * 971 + 13);
            const h2 = hash(li * 653 + 7);
            const h3 = hash(li * 433 + 29);
            const h4 = hash(li * 257 + 41);
            const h5 = hash(li * 829 + 53);

            const sx = 60 + h1 * 680;
            const sy = 10 + h2 * 80;
            // Target in a different direction each time
            const angle = h3 * Math.PI * 2;
            const laserLen = 30 + h4 * 80;
            const tx = sx + Math.cos(angle) * laserLen;
            const ty = sy + Math.sin(angle) * laserLen * 0.4;

            // Random color from a palette
            const colors = [
                ['#ff4422', '#ff2200'],
                ['#44ddff', '#00ccff'],
                ['#44ff66', '#00cc44'],
                ['#ffaa22', '#ff6600'],
                ['#ff44ff', '#cc00cc'],
                ['#aaaaff', '#6666ff']
            ];
            const colorPick = colors[Math.floor(h5 * colors.length)];

            ctx.save();
            ctx.globalAlpha = alpha * laserAlpha;
            ctx.shadowColor = colorPick[1];
            ctx.shadowBlur = 5 + h4 * 4;
            ctx.strokeStyle = colorPick[0];
            ctx.lineWidth = 0.8 + h3;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(tx, ty);
            ctx.stroke();
            ctx.restore();
        }

        // Distant explosions on higher levels
        if (currentLevel >= 10) {
            for (let ei = 0; ei < 3; ei++) {
                const seed = (gameTime * 2 + ei * 311) % 200;
                if (seed > 20) continue;
                const ex = 100 + ((ei * 277) % 600);
                const ey = 25 + ((ei * 133) % 60);
                const er = 3 + (1 - seed / 20) * 8;
                const ea = (1 - seed / 20) * 0.4;

                ctx.save();
                ctx.globalAlpha = alpha * ea;
                const eg = ctx.createRadialGradient(ex, ey, 0, ex, ey, er);
                eg.addColorStop(0, 'rgba(255,200,100,0.8)');
                eg.addColorStop(0.5, 'rgba(255,100,30,0.4)');
                eg.addColorStop(1, 'rgba(255,50,0,0)');
                ctx.fillStyle = eg;
                ctx.beginPath();
                ctx.arc(ex, ey, er, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        ctx.restore();
    }

    function drawSpaceGrid() {
        ctx.save();
        ctx.strokeStyle = 'rgba(40,60,120,0.08)';
        ctx.lineWidth = 1;
        const gridY = canvas.height - 60;
        for (let i = 0; i < 5; i++) {
            const y = gridY + i * 15;
            ctx.globalAlpha = 0.1 - i * 0.015;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        const cxGrid = canvas.width / 2;
        for (let i = -10; i <= 10; i++) {
            const topX = cxGrid + i * 30;
            const botX = cxGrid + i * 50;
            ctx.globalAlpha = 0.06;
            ctx.beginPath();
            ctx.moveTo(topX, gridY);
            ctx.lineTo(botX, canvas.height);
            ctx.stroke();
        }
        ctx.restore();
    }

    // ===================== DRAWING: PLATFORMS =====================

    function drawPlatform(p) {
        const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
        grad.addColorStop(0, '#3a3a5a');
        grad.addColorStop(0.5, '#2a2a45');
        grad.addColorStop(1, '#1a1a30');
        ctx.fillStyle = grad;
        roundRect(p.x, p.y, p.width, p.height, 3);
        ctx.fill();

        ctx.strokeStyle = 'rgba(100,100,150,0.3)';
        ctx.lineWidth = 1;
        roundRect(p.x + 0.5, p.y + 0.5, p.width - 1, p.height - 1, 3);
        ctx.stroke();

        // Glowing blue top edge
        ctx.save();
        ctx.shadowColor = '#4488ff';
        ctx.shadowBlur = 6;
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x + 3, p.y + 1);
        ctx.lineTo(p.x + p.width - 3, p.y + 1);
        ctx.stroke();
        ctx.restore();

        // Hex pattern
        ctx.fillStyle = 'rgba(60,70,100,0.15)';
        for (let hx = p.x + 10; hx < p.x + p.width - 10; hx += 20) {
            if (p.height > 12) {
                drawHexagon(hx, p.y + p.height / 2 + 2, 4);
                ctx.fill();
            }
        }

        // Corner rivets
        ctx.fillStyle = '#555570';
        ctx.beginPath();
        ctx.arc(p.x + 5, p.y + p.height / 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p.x + p.width - 5, p.y + p.height / 2, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // ===================== DRAWING: PITS (Void Rifts) =====================

    function drawPit(pit) {
        const cx = pit.x + pit.width / 2;
        const cy = pit.y + pit.height / 2;
        const rx = pit.width / 2;
        const ry = pit.height / 3;

        // Outer glow ring
        ctx.save();
        ctx.shadowColor = '#8833cc';
        ctx.shadowBlur = 20;
        ctx.strokeStyle = 'rgba(150,50,220,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Vortex fill - radial gradient, transparent edges
        const vg = ctx.createRadialGradient(cx, cy, 0, cx, cy, rx);
        vg.addColorStop(0, 'rgba(80,0,120,0.6)');
        vg.addColorStop(0.4, 'rgba(40,0,80,0.4)');
        vg.addColorStop(0.8, 'rgba(20,0,40,0.15)');
        vg.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = vg;
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        ctx.fill();

        // Swirling spiral arms (like warp gate but purple)
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        ctx.clip();
        for (let arm = 0; arm < 3; arm++) {
            const baseAngle = gameTime * 0.06 + arm * (Math.PI * 2 / 3);
            ctx.strokeStyle = `rgba(180,60,255,0.25)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let t = 0; t < 1; t += 0.03) {
                const angle = baseAngle + t * Math.PI * 2;
                const dist = 1 - t;
                const sx = cx + Math.cos(angle) * rx * dist;
                const sy = cy + Math.sin(angle) * ry * dist;
                if (t === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
            }
            ctx.stroke();
        }
        ctx.restore();

        // Center bright core
        ctx.save();
        ctx.shadowColor = '#aa44ff';
        ctx.shadowBlur = 15;
        const cg = ctx.createRadialGradient(cx, cy, 0, cx, cy, 6);
        cg.addColorStop(0, 'rgba(200,150,255,0.7)');
        cg.addColorStop(1, 'rgba(100,0,200,0)');
        ctx.fillStyle = cg;
        ctx.beginPath();
        ctx.arc(cx, cy, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Rising wisp particles
        if (frameCount % 6 === 0) {
            spawnParticle({
                x: cx + (Math.random() - 0.5) * pit.width * 0.6, y: cy,
                velX: (Math.random() - 0.5) * 0.4, velY: -0.4 - Math.random() * 0.6,
                life: 35 + Math.random() * 25, size: 2 + Math.random() * 2,
                color: '#bb66ff', alpha: 0.35
            });
        }

        // Particles sucked inward (like warp gate)
        if (frameCount % 12 === 0) {
            const angle = Math.random() * Math.PI * 2;
            const dist = rx + 10;
            spawnParticle({
                x: cx + Math.cos(angle) * dist, y: cy + Math.sin(angle) * ry / rx * dist,
                velX: -Math.cos(angle) * 1.2, velY: -Math.sin(angle) * 0.8,
                life: 18, size: 1.5, color: '#9944cc', alpha: 0.4
            });
        }
    }

    // ===================== DRAWING: SPIKES (Laser Barriers) =====================

    function drawSpike(spike) {
        const numLasers = Math.max(1, Math.floor(spike.width / 16));
        const laserW = spike.width / numLasers;

        ctx.fillStyle = '#1a1a2a';
        ctx.fillRect(spike.x, spike.y + spike.height - 10, spike.width, 10);
        ctx.strokeStyle = '#333355';
        ctx.lineWidth = 1;
        ctx.strokeRect(spike.x, spike.y + spike.height - 10, spike.width, 10);

        for (let i = 0; i < numLasers; i++) {
            const lx = spike.x + i * laserW + laserW / 2;
            const flicker = 0.7 + 0.3 * Math.sin(gameTime * 0.2 + i * 1.5);

            ctx.save();
            ctx.globalAlpha = flicker;
            ctx.shadowColor = '#ff2200';
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#ff2200';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(lx, spike.y);
            ctx.lineTo(lx, spike.y + spike.height - 10);
            ctx.stroke();

            ctx.strokeStyle = '#ff8866';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(lx, spike.y);
            ctx.lineTo(lx, spike.y + spike.height - 10);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(lx, spike.y + 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // ===================== DRAWING: COINS (Energy Crystals) =====================

    function drawCoin(coin) {
        const time = gameTime * 0.05;
        const bounce = Math.sin(time + coin.x * 0.1) * 3;
        const cx = coin.x + 10;
        const cy = coin.y + 10 + bounce;
        const rotation = time + coin.x * 0.05;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);

        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 12;

        const s = 8;
        const grad = ctx.createLinearGradient(0, -s, 0, s);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.5, '#00ffff');
        grad.addColorStop(1, '#0088aa');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.6, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s * 0.6, 0);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.moveTo(0, -s * 0.5);
        ctx.lineTo(s * 0.3, 0);
        ctx.lineTo(0, s * 0.5);
        ctx.lineTo(-s * 0.3, 0);
        ctx.closePath();
        ctx.fill();

        ctx.restore();

        if (frameCount % 30 === Math.floor(coin.x) % 30) {
            spawnParticle({
                x: cx + (Math.random() - 0.5) * 16, y: cy + (Math.random() - 0.5) * 16,
                velX: (Math.random() - 0.5) * 0.5, velY: -Math.random() * 0.5,
                life: 20 + Math.random() * 20, size: 1.5, color: '#00ffff'
            });
        }
    }

    // ===================== DRAWING: GOAL (Warp Gate) =====================

    function drawGoal(goal) {
        const cx = goal.x + goal.width / 2;
        const cy = goal.y + goal.height / 2;
        const r = Math.min(goal.width, goal.height) / 2 + 5;

        ctx.save();
        ctx.shadowColor = '#4488ff';
        ctx.shadowBlur = 15;
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cx, cy, r + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        const vg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        vg.addColorStop(0, '#00ffff');
        vg.addColorStop(0.4, '#0066ff');
        vg.addColorStop(0.8, '#220066');
        vg.addColorStop(1, '#110033');
        ctx.fillStyle = vg;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();

        // Spiral arms
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.clip();
        for (let arm = 0; arm < 3; arm++) {
            const baseAngle = gameTime * 0.05 + arm * (Math.PI * 2 / 3);
            ctx.strokeStyle = 'rgba(0,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t < 1; t += 0.02) {
                const angle = baseAngle + t * Math.PI * 2;
                const dist = r * (1 - t);
                const sx = cx + Math.cos(angle) * dist;
                const sy = cy + Math.sin(angle) * dist;
                if (t === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
            }
            ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 20;
        const cg = ctx.createRadialGradient(cx, cy, 0, cx, cy, 10);
        cg.addColorStop(0, 'rgba(255,255,255,0.9)');
        cg.addColorStop(1, 'rgba(0,255,255,0)');
        ctx.fillStyle = cg;
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        const pulse = 0.6 + 0.4 * Math.sin(gameTime * 0.08);
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('WARP', cx, cy);
        ctx.restore();

        if (frameCount % 5 === 0) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            spawnParticle({
                x: cx + Math.cos(angle) * dist, y: cy + Math.sin(angle) * dist,
                velX: -Math.cos(angle) * 1.5, velY: -Math.sin(angle) * 1.5,
                life: 20, size: 2, color: '#00ffff'
            });
        }
    }

    // ===================== DRAWING: MOVING OBSTACLES (Drones) =====================

    function drawMovingObstacle(obs) {
        const cx = obs.x + obs.width / 2;
        const cy = obs.y + obs.height / 2 + Math.sin(gameTime * 0.08) * 3;
        const r = obs.width / 2;

        ctx.save();
        ctx.shadowColor = '#ff2200';
        ctx.shadowBlur = 12;

        ctx.fillStyle = '#2a2a40';
        ctx.strokeStyle = '#ff2200';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy - r);
        ctx.lineTo(cx + r, cy);
        ctx.lineTo(cx, cy + r);
        ctx.lineTo(cx - r, cy);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0;

        const dx = player.x + player.width / 2 - cx;
        const dy = player.y + player.height / 2 - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const lookX = (dx / dist) * 2;
        const lookY = (dy / dist) * 2;

        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(cx + lookX, cy + lookY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffff00';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(cx + lookX, cy + lookY, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ===================== DRAWING: PLAYER (Space Explorer) =====================

    function drawPlayerCharacter(px, py, pfacing, alpha) {
        const cx = px + player.width / 2;
        const footY = py + player.height;
        const breathBob = player.onGround && Math.abs(player.velX) < 0.5 ? Math.sin(player.breathPhase) * 1.0 : 0;
        const sy = player.squashStretch;
        const sx = 1 / Math.sqrt(sy);
        const energyPulse = 0.5 + 0.5 * Math.sin(gameTime * 0.1);

        ctx.save();
        if (alpha !== undefined) ctx.globalAlpha = alpha;
        ctx.translate(cx, footY);
        ctx.scale(pfacing * sx, sy);

        const suitColor = '#1a1a2e';
        const suitLight = '#2a2a4e';
        const cyanAccent = '#00ffff';
        const visorColor = '#ff8800';
        const bootColor = '#2a2a3e';

        const legSpread = 4;
        const legW = 5;
        const legLen = 10;

        if (player.jumping) {
            ctx.fillStyle = suitColor;
            ctx.fillRect(-legSpread - legW / 2, -12, legW, 7);
            ctx.fillRect(legSpread - legW / 2, -12, legW, 7);
            ctx.fillStyle = bootColor;
            ctx.fillRect(-legSpread - legW / 2 - 1, -5, legW + 2, 4);
            ctx.fillRect(legSpread - legW / 2 - 1, -5, legW + 2, 4);
        } else if (Math.abs(player.velX) > 0.5 && player.onGround) {
            const phase = player.runPhase;
            ctx.save();
            ctx.translate(-legSpread, -legLen - 2);
            ctx.rotate(Math.sin(phase) * 0.5);
            ctx.fillStyle = suitColor;
            ctx.fillRect(-legW / 2, 0, legW, legLen);
            ctx.fillStyle = bootColor;
            ctx.fillRect(-legW / 2 - 1, legLen - 4, legW + 2, 4);
            ctx.restore();
            ctx.save();
            ctx.translate(legSpread, -legLen - 2);
            ctx.rotate(Math.sin(phase + Math.PI) * 0.5);
            ctx.fillStyle = suitColor;
            ctx.fillRect(-legW / 2, 0, legW, legLen);
            ctx.fillStyle = bootColor;
            ctx.fillRect(-legW / 2 - 1, legLen - 4, legW + 2, 4);
            ctx.restore();
        } else {
            ctx.fillStyle = suitColor;
            ctx.fillRect(-legSpread - legW / 2, -legLen - 2, legW, legLen);
            ctx.fillRect(legSpread - legW / 2, -legLen - 2, legW, legLen);
            ctx.fillStyle = bootColor;
            ctx.fillRect(-legSpread - legW / 2 - 1, -5, legW + 2, 4);
            ctx.fillRect(legSpread - legW / 2 - 1, -5, legW + 2, 4);
        }

        // Body
        const bodyW = 16;
        const bodyH = 12;
        const bodyTop = -legLen - 2 - bodyH + breathBob;

        const bodyGrad = ctx.createLinearGradient(0, bodyTop, 0, bodyTop + bodyH);
        bodyGrad.addColorStop(0, suitLight);
        bodyGrad.addColorStop(1, suitColor);
        ctx.fillStyle = bodyGrad;
        roundRect(-bodyW / 2, bodyTop, bodyW, bodyH, 3);
        ctx.fill();

        // Energy lines
        ctx.save();
        ctx.globalAlpha = (alpha !== undefined ? alpha : 1) * (0.4 + 0.4 * energyPulse);
        ctx.strokeStyle = cyanAccent;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-bodyW / 2 + 2, bodyTop + 2);
        ctx.lineTo(-bodyW / 2 + 2, bodyTop + bodyH - 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bodyW / 2 - 2, bodyTop + 2);
        ctx.lineTo(bodyW / 2 - 2, bodyTop + bodyH - 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-bodyW / 2 + 3, bodyTop + bodyH / 2);
        ctx.lineTo(bodyW / 2 - 3, bodyTop + bodyH / 2);
        ctx.stroke();
        ctx.restore();

        // Helmet
        const headR = 7;
        const headY = bodyTop - headR + 2;

        const helmGrad = ctx.createRadialGradient(0, headY - 2, 1, 0, headY, headR + 2);
        helmGrad.addColorStop(0, '#4a4a6a');
        helmGrad.addColorStop(0.7, '#2a2a4a');
        helmGrad.addColorStop(1, '#1a1a30');
        ctx.fillStyle = helmGrad;
        ctx.beginPath();
        ctx.arc(0, headY, headR + 1, 0, Math.PI * 2);
        ctx.fill();

        // Cyan accent ring
        ctx.save();
        ctx.globalAlpha = (alpha !== undefined ? alpha : 1) * (0.5 + 0.3 * energyPulse);
        ctx.strokeStyle = cyanAccent;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, headY, headR + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Orange visor
        ctx.save();
        ctx.shadowColor = visorColor;
        ctx.shadowBlur = 6;
        const visorGrad = ctx.createLinearGradient(-5, headY - 1, 5, headY + 3);
        visorGrad.addColorStop(0, '#ffaa44');
        visorGrad.addColorStop(1, '#cc6600');
        ctx.fillStyle = visorGrad;
        ctx.beginPath();
        ctx.ellipse(1, headY + 1, 5, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.beginPath();
        ctx.ellipse(-1, headY - 0.5, 2.5, 1.5, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Shield visual
        if (powerups.shield.active && (alpha === undefined)) {
            ctx.save();
            ctx.globalAlpha = 0.3 + 0.15 * energyPulse;
            ctx.strokeStyle = '#aa44ff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#aa44ff';
            ctx.shadowBlur = 10;
            drawHexagon(0, bodyTop + bodyH / 2 - headR, headR + 8);
            ctx.stroke();
            ctx.restore();
        }

        ctx.restore();
    }

    function drawPlayerTrail() {
        for (let i = player.trailHistory.length - 1; i >= 0; i--) {
            const t = player.trailHistory[i];
            const alpha = 0.12 * (1 - i / player.trailHistory.length);
            drawPlayerCharacter(t.x, t.y, t.facing, alpha);
        }
    }

    function drawPlayer() {
        for (let ai of powerups.warpDash.afterimages) {
            drawPlayerCharacter(ai.x, ai.y, ai.facing, ai.alpha * 0.4);
        }
        drawPlayerTrail();
        drawPlayerCharacter(player.x, player.y, player.facing);
    }

    // ===================== DRAWING: POWERUP PICKUPS =====================

    function drawPowerupPickup(pickup) {
        const time = gameTime * 0.05;
        const bounce = Math.sin(time + pickup.x * 0.1) * 4;
        const pcx = pickup.x;
        const pcy = pickup.y + bounce;
        const rotation = time * 0.8;
        const color = getPowerupColor(pickup.type);

        ctx.save();
        ctx.translate(pcx, pcy);
        ctx.rotate(rotation);

        ctx.shadowColor = color;
        ctx.shadowBlur = 15;

        const s = 12;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.7, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s * 0.7, 0);
        ctx.closePath();
        ctx.fill();

        ctx.globalAlpha = 0.8;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 7px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        let label = '';
        switch (pickup.type) {
            case 'doubleJump': label = 'JJ'; break;
            case 'jetpack': label = 'JP'; break;
            case 'warpDash': label = 'WD'; break;
            case 'shield': label = 'SH'; break;
        }
        ctx.fillText(label, pcx, pcy);
        ctx.restore();
    }

    // ===================== DRAWING: HUD =====================

    function drawHeart(cx, cy, size, color) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(cx, cy + size * 0.3);
        ctx.bezierCurveTo(cx, cy - size * 0.3, cx - size, cy - size * 0.5, cx - size, cy + size * 0.1);
        ctx.bezierCurveTo(cx - size, cy + size * 0.6, cx, cy + size, cx, cy + size);
        ctx.bezierCurveTo(cx, cy + size, cx + size, cy + size * 0.6, cx + size, cy + size * 0.1);
        ctx.bezierCurveTo(cx + size, cy - size * 0.5, cx, cy - size * 0.3, cx, cy + size * 0.3);
        ctx.fill();
        ctx.restore();
    }

    function drawPowerupIcon(x, y, label, color, active) {
        ctx.save();
        ctx.globalAlpha = active ? 0.9 : 0.3;
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = active ? 6 : 0;
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
        ctx.restore();
    }

    function drawFuelBar(x, y, w, h, fuel, maxFuel) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(x, y, w, h);
        const frac = fuel / maxFuel;
        ctx.fillStyle = frac > 0.3 ? '#ff8800' : '#ff4400';
        ctx.fillRect(x, y, w * frac, h);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
    }

    function drawCooldownOverlay(x, y, r, cooldown, maxCooldown) {
        if (cooldown <= 0) return;
        const frac = cooldown / maxCooldown;
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, r, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * frac);
        ctx.lineTo(x, y);
        ctx.fill();
        ctx.restore();
    }

    function drawHUD() {
        ctx.fillStyle = 'rgba(0,0,20,0.6)';
        ctx.fillRect(0, 0, canvas.width, 40);
        ctx.strokeStyle = '#2244aa';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 40);
        ctx.lineTo(canvas.width, 40);
        ctx.stroke();

        const heartSize = 8;
        const heartSpacing = 22;
        const maxHearts = Math.min(lives, 15);
        for (let i = 0; i < maxHearts; i++) {
            drawHeart(18 + i * heartSpacing, 18, heartSize, '#ff0000');
        }
        if (lives > 15) {
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('+' + (lives - 15), 18 + 15 * heartSpacing, 20);
        }

        ctx.fillStyle = '#00ffff';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('LEVEL ' + currentLevel, canvas.width / 2, 20);

        // Crystal icon
        ctx.save();
        ctx.translate(canvas.width - 90, 20);
        ctx.rotate(Math.PI / 4);
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 4;
        ctx.fillRect(-5, -5, 10, 10);
        ctx.restore();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(coins + '/' + COINS_FOR_LIFE, canvas.width - 70, 21);

        // Powerup indicators
        let iconX = canvas.width - 30;
        const iconY = 58;

        drawPowerupIcon(iconX, iconY, 'JJ', '#00ff88', powerups.doubleJump.active);
        if (powerups.doubleJump.active) {
            for (let d = 0; d < powerups.doubleJump.maxAirJumps; d++) {
                ctx.fillStyle = d < powerups.doubleJump.airJumpsRemaining ? '#00ff88' : '#333';
                ctx.beginPath();
                ctx.arc(iconX - 6 + d * 6, iconY + 14, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        iconX -= 30;

        drawPowerupIcon(iconX, iconY, 'JP', '#ff8800', powerups.jetpack.active);
        if (powerups.jetpack.active) {
            drawFuelBar(iconX - 10, iconY + 12, 20, 4, powerups.jetpack.fuel, powerups.jetpack.maxFuel);
        }
        iconX -= 30;

        drawPowerupIcon(iconX, iconY, 'WD', '#00ffff', powerups.warpDash.active);
        if (powerups.warpDash.active) {
            drawCooldownOverlay(iconX, iconY, 10, powerups.warpDash.cooldown, powerups.warpDash.cooldownMax);
        }
        iconX -= 30;

        drawPowerupIcon(iconX, iconY, 'SH', '#aa44ff', powerups.shield.active);
    }

    // ===================== READY COUNTDOWN =====================

    function drawReadyOverlay() {
        // Dim overlay
        ctx.fillStyle = 'rgba(0, 0, 10, 0.4)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const secondsLeft = Math.ceil(readyCountdown / 60);
        const frameFrac = (readyCountdown % 60) / 60;
        const scale = 1 + frameFrac * 0.5; // Pulse on each new second
        const alpha = 0.6 + 0.4 * frameFrac;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 25;
        ctx.fillStyle = '#00ffff';
        ctx.font = `bold ${Math.floor(48 * scale)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const text = secondsLeft > 1 ? 'Ok' : secondsLeft > 0 ? 'Ready?' : 'GO!';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        ctx.restore();

        // Level name subtitle
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#aaddff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('LEVEL ' + currentLevel, canvas.width / 2, canvas.height / 2 - 50);
        ctx.restore();
    }

    // ===================== GAME OVER / WIN SCREENS =====================

    function drawGameOverScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const vigGrad = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 100,
            canvas.width / 2, canvas.height / 2, 400
        );
        vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vigGrad.addColorStop(1, 'rgba(0,0,0,0.5)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isWin = lives > 0;
        const glowColor = isWin ? '#00ff88' : '#ff0000';
        const text = isWin ? 'YOU WIN!' : 'GAME OVER';

        ctx.save();
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 30;
        ctx.fillStyle = glowColor;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const titleY = isWin ? canvas.height / 2 - 60 : canvas.height / 2 - 20;
        ctx.fillText(text, canvas.width / 2, titleY);
        ctx.fillText(text, canvas.width / 2, titleY);
        ctx.restore();

        if (isWin) {
            // Credits
            ctx.fillStyle = '#aaddff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';

            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Thanks to', canvas.width / 2, canvas.height / 2 + 30);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Mike McClarin', canvas.width / 2, canvas.height / 2 + 55);
            ctx.fillText('Andy McClarin', canvas.width / 2, canvas.height / 2 + 80);
            ctx.fillText('Claude Codingtion McCli', canvas.width / 2, canvas.height / 2 + 105);

            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('for all their hard work creating this fun game for you!', canvas.width / 2, canvas.height / 2 + 135);

            ctx.fillStyle = '#aaccff';
            ctx.font = '14px Arial';
            ctx.fillText('Please give us your feedback and let us know', canvas.width / 2, canvas.height / 2 + 165);
            ctx.fillText('what kind of game you would like to see next.', canvas.width / 2, canvas.height / 2 + 185);
        }

        const pulse = 0.4 + 0.6 * Math.sin(gameTime * 0.08);
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press R or Enter to restart', canvas.width / 2, isWin ? canvas.height / 2 + 220 : canvas.height / 2 + 80);
        ctx.restore();
    }

    // ===================== AMBIENT PARTICLES =====================

    function spawnAmbientParticles() {
        if (frameCount % 10 === 0) {
            spawnParticle({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                velX: (Math.random() - 0.5) * 0.4,
                velY: (Math.random() - 0.5) * 0.4,
                life: 80 + Math.random() * 60,
                size: 1 + Math.random() * 1.5,
                color: Math.random() > 0.5 ? '#00ccff' : '#aaccff',
                alpha: 0.15
            });
        }
    }

    // ===================== SCENE DRAWING =====================

    function drawScene() {
        drawBackground();
        drawStars();
        drawSpaceBattle();
        drawSpaceGrid();

        const level = levels[currentLevel];

        for (let pit of level.pits) drawPit(pit);
        for (let p of level.platforms) drawPlatform(p);
        for (let spike of level.spikes) drawSpike(spike);

        if (level.coins) {
            for (let coin of level.coins) {
                if (!coin.collected) drawCoin(coin);
            }
        }

        if (level.powerupPickups) {
            for (let p of level.powerupPickups) {
                if (!p.collected) drawPowerupPickup(p);
            }
        }

        drawGoal(level.goal);

        if (level.movingObstacles) {
            for (let obs of level.movingObstacles) drawMovingObstacle(obs);
        }

        drawPlayer();
    }

    // ===================== GAME LOOP =====================

    function gameLoop() {
        frameCount++;
        gameTime++;

        if (deathAnimating) {
            updateDeathAnimation();
            updateParticles();

            ctx.save();
            if (shakeIntensity > 0) {
                const shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
                const shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
                ctx.translate(shakeX, shakeY);
            }

            drawScene();
            drawParticles();
            drawDeathEffects();
            drawHUD();

            ctx.restore();

            requestAnimationFrame(gameLoop);
            return;
        }

        if (!gameOver && !levelComplete && readyCountdown <= 0) {
            updatePlayer();
            updateMovingObstacles();
            spawnAmbientParticles();
        } else if (levelComplete) {
            if (currentLevel < 15) {
                currentLevel++;
                resetLevel();
                readyCountdown = READY_DURATION;
            } else {
                gameOver = true;
            }
        } else if (readyCountdown > 0) {
            readyCountdown--;
            updateMovingObstacles();
            spawnAmbientParticles();
        }

        updateParticles();
        drawScene();
        drawParticles();
        drawHUD();

        if (readyCountdown > 0) {
            drawReadyOverlay();
        }

        if (gameOver) {
            drawGameOverScreen();
            if (isMobile && btnRestart) btnRestart.classList.add('show');
        } else {
            if (isMobile && btnRestart) btnRestart.classList.remove('show');
        }

        requestAnimationFrame(gameLoop);
    }

    // Initialize first level
    resetLevel();
    gameLoop();
    </script>
</body>
</html>
