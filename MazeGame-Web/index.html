<!DOCTYPE html>
<html>
<head>
    <title>Maze Pitfalls</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        canvas {
            background: #1a1a1a;
            border: 3px solid #fff;
            display: block;
            margin-bottom: 20px;
        }
        #hud {
            font-size: 24px;
            text-align: center;
        }
        #lives { color: #ff0000; margin: 10px; }
        #level { color: #00ff00; margin: 10px; }
    </style>
</head>
<body>
    <h1>MAZE PITFALLS</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="hud">
        <div id="lives">Lives: 10</div>
        <div id="level">Level: 1</div>
        <p style="margin-top: 20px; font-size: 16px;">
            Arrow Keys = Move | Spacebar = Jump<br>
            Reach the green EXIT!
        </p>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let lives = 10;
    let currentLevel = 1;
    let gameOver = false;
    let levelComplete = false;

    // Player
    const player = {
        x: 50,
        y: 550,
        width: 20,
        height: 20,
        velX: 0,
        velY: 0,
        speed: 5,
        jumping: false,
        startX: 50,
        startY: 550,
        animFrame: 0,
        facing: 1
    };

    // Input
    const keys = {};
    window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        if (e.key === ' ') {
            e.preventDefault();
            if (!player.jumping) {
                player.velY = -12;
                player.jumping = true;
            }
        }
    });
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // Levels
    const levels = {
        1: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 100, y: 500, width: 200, height: 20},
                {x: 450, y: 450, width: 200, height: 20},
                {x: 200, y: 350, width: 150, height: 20},
                {x: 500, y: 300, width: 150, height: 20}
            ],
            pits: [
                {x: 350, y: 520, width: 80, height: 60}
            ],
            spikes: [
                {x: 600, y: 560, width: 80, height: 40}
            ],
            goal: {x: 750, y: 500, width: 40, height: 80}
        },
        2: {
            platforms: [
                {x: 0, y: 580, width: 800, height: 20},
                {x: 50, y: 480, width: 120, height: 20},
                {x: 250, y: 420, width: 120, height: 20},
                {x: 450, y: 360, width: 120, height: 20},
                {x: 650, y: 300, width: 120, height: 20}
            ],
            pits: [
                {x: 200, y: 500, width: 40, height: 80},
                {x: 400, y: 440, width: 40, height: 80},
                {x: 600, y: 380, width: 40, height: 80}
            ],
            spikes: [
                {x: 100, y: 560, width: 40, height: 40},
                {x: 500, y: 560, width: 40, height: 40}
            ],
            goal: {x: 730, y: 220, width: 40, height: 80}
        }
    };

    function resetLevel() {
        player.x = player.startX;
        player.y = player.startY;
        player.velX = 0;
        player.velY = 0;
        player.jumping = false;
        levelComplete = false;
    }

    function updatePlayer() {
        // Horizontal movement
        player.velX = 0;
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            player.velX = -player.speed;
            player.facing = -1;
        }
        if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            player.velX = player.speed;
            player.facing = 1;
        }

        player.x += player.velX;

        // Gravity
        player.velY += 0.8;
        player.y += player.velY;

        // Boundary check
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

        // Platform collision
        let onPlatform = false;
        const level = levels[currentLevel];
        for (let platform of level.platforms) {
            if (
                player.velY >= 0 &&
                player.y + player.height <= platform.y + 5 &&
                player.y + player.height + player.velY >= platform.y &&
                player.x + player.width > platform.x &&
                player.x < platform.x + platform.width
            ) {
                player.y = platform.y - player.height;
                player.velY = 0;
                player.jumping = false;
                onPlatform = true;
            }
        }

        // Pit collision
        for (let pit of level.pits) {
            if (
                player.x + player.width > pit.x &&
                player.x < pit.x + pit.width &&
                player.y + player.height > pit.y &&
                player.y < pit.y + pit.height
            ) {
                lives--;
                if (lives <= 0) {
                    gameOver = true;
                } else {
                    resetLevel();
                }
                return;
            }
        }

        // Spike collision
        for (let spike of level.spikes) {
            if (
                player.x + player.width > spike.x &&
                player.x < spike.x + spike.width &&
                player.y + player.height > spike.y &&
                player.y < spike.y + spike.height
            ) {
                lives--;
                if (lives <= 0) {
                    gameOver = true;
                } else {
                    resetLevel();
                }
                return;
            }
        }

        // Goal collision
        if (
            player.x + player.width > level.goal.x &&
            player.x < level.goal.x + level.goal.width &&
            player.y + player.height > level.goal.y &&
            player.y < level.goal.y + level.goal.height
        ) {
            levelComplete = true;
        }

        // Animation
        if (onPlatform && player.velX !== 0) {
            player.animFrame = (player.animFrame + 0.15) % 2;
        } else {
            player.animFrame = 0;
        }
    }

    function drawPlayer() {
        ctx.fillStyle = '#ffff00';
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y);
        ctx.scale(player.facing, 1);
        ctx.translate(-(player.width / 2), 0);

        // Body
        ctx.fillRect(0, 0, player.width, 12);

        // Head
        ctx.beginPath();
        ctx.arc(player.width / 2, -2, 4, 0, Math.PI * 2);
        ctx.fill();

        // Legs
        if (player.jumping) {
            ctx.fillRect(6, 12, 4, 8);
            ctx.fillRect(10, 12, 4, 8);
        } else if (Math.abs(player.velX) > 0) {
            const legFrame = Math.floor(player.animFrame);
            if (legFrame === 0) {
                ctx.fillRect(6, 12, 4, 8);
                ctx.fillRect(10, 12, 4, 8);
            } else {
                ctx.fillRect(5, 14, 4, 6);
                ctx.fillRect(11, 10, 4, 10);
            }
        } else {
            ctx.fillRect(6, 12, 4, 8);
            ctx.fillRect(10, 12, 4, 8);
        }

        ctx.restore();
    }

    function draw() {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const level = levels[currentLevel];

        // Draw platforms
        ctx.fillStyle = '#00ff00';
        for (let platform of level.platforms) {
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }

        // Draw pits
        ctx.fillStyle = '#444';
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        for (let pit of level.pits) {
            ctx.fillRect(pit.x, pit.y, pit.width, pit.height);
            for (let i = 0; i < pit.width; i += 8) {
                ctx.beginPath();
                ctx.moveTo(pit.x + i, pit.y);
                ctx.lineTo(pit.x + i + pit.height, pit.y + pit.height);
                ctx.stroke();
            }
        }

        // Draw spikes
        ctx.fillStyle = '#ff6600';
        for (let spike of level.spikes) {
            ctx.beginPath();
            ctx.moveTo(spike.x, spike.y + spike.height);
            ctx.lineTo(spike.x + spike.width / 2, spike.y);
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
            ctx.fill();
        }

        // Draw goal
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(level.goal.x, level.goal.y, level.goal.width, level.goal.height);
        ctx.fillStyle = '#000';
        ctx.fillRect(level.goal.x + 5, level.goal.y + 10, 30, 15);

        // Draw player
        drawPlayer();

        // Update HUD
        document.getElementById('lives').textContent = 'Lives: ' + lives;
        document.getElementById('level').textContent = 'Level: ' + currentLevel;
    }

    function gameLoop() {
        if (!gameOver && !levelComplete) {
            updatePlayer();
        } else if (levelComplete) {
            if (currentLevel < 2) {
                currentLevel++;
                resetLevel();
            } else {
                gameOver = true;
            }
        }

        if (gameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            if (lives > 0) {
                ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
            } else {
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
            }
            ctx.font = '20px Arial';
            ctx.fillText('Refresh to restart', canvas.width / 2, canvas.height / 2 + 50);
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    gameLoop();
    </script>
</body>
</html>